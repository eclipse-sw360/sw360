/*
 * Copyright Siemens AG, 2016. Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.vulnerabilities.db;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;

import org.eclipse.sw360.datahandler.common.CommonUtils;
import org.eclipse.sw360.datahandler.common.DatabaseSettings;
import org.eclipse.sw360.datahandler.couchdb.DatabaseConnector;
import org.eclipse.sw360.datahandler.thrift.RequestStatus;
import org.eclipse.sw360.datahandler.thrift.SW360Exception;
import org.eclipse.sw360.datahandler.thrift.VerificationStateInfo;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.*;
import org.eclipse.sw360.vulnerabilities.common.VulnerabilityMapper;
import org.ektorp.http.HttpClient;
import org.apache.http.HttpStatus;
import org.apache.commons.lang.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.thrift.TBase;

import java.net.MalformedURLException;
import java.util.*;
import java.util.function.Supplier;

/**
 * Class for accessing the CouchDB database
 *
 * @author stefan.jaeger@evosoft.com
 */
public class VulnerabilityDatabaseHandler {

    private static final Logger log = LogManager.getLogger(VulnerabilityDatabaseHandler.class);

    private final VulnerabilityRepository vulRepo;
    private final VulnerabilityRelationRepository relationRepo;

    public VulnerabilityDatabaseHandler() throws MalformedURLException {
        DatabaseConnector db = new DatabaseConnector(DatabaseSettings.getConfiguredHttpClient(),
                DatabaseSettings.COUCH_DB_VM);

        vulRepo = new VulnerabilityRepository(db);
        relationRepo = new VulnerabilityRelationRepository(db);
    }

    public VulnerabilityDatabaseHandler(Supplier<HttpClient> client, String vmDbName) throws MalformedURLException {
        DatabaseConnector db = new DatabaseConnector(client, vmDbName);
        vulRepo = new VulnerabilityRepository(db);
        relationRepo = new VulnerabilityRelationRepository(db);
    }

    public <T extends TBase> RequestStatus add(T element) {
        if (element == null) {
            log.error("cannot add null element");
            return RequestStatus.FAILURE;
        }
        log.debug("adding element " + element.toString());
        try {
            if (Vulnerability.class.isAssignableFrom(element.getClass())) {
                vulRepo.add((Vulnerability) element);
                log.info("Vulnerability id = " + ((Vulnerability) element).getId());
            } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(element.getClass())) {
                relationRepo.add((ReleaseVulnerabilityRelation) element);
            } else {
                throw new IllegalArgumentException("unknown type " + element.getClass().getSimpleName());
            }
            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on adding " + element.getClass().getSimpleName() + ": " + e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> RequestStatus add(Class<T> type, Collection<T> elements) {
        if (type == null || elements == null) {
            log.error("type/elements cannot be null");
            return RequestStatus.FAILURE;
        }
        try {
            log.debug("adding " + elements.size() + " elements via bulk");
            if (Vulnerability.class.isAssignableFrom(type)) {
                vulRepo.executeBulk(elements);
            } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
                relationRepo.executeBulk(elements);
            } else {
                throw new IllegalArgumentException("unknown type " + type.getSimpleName());
            }

            log.debug("adding " + elements.size() + " elements via bulk finished");
            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on bulk updating " + type.getSimpleName() + ": " + e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public RequestStatus addRelationIfNecessary(String releaseId, String vulnerabilityId, Optional<String> usedNeedle) {
        ReleaseVulnerabilityRelation relation = getRelationByIds(releaseId, vulnerabilityId);
        if (relation != null) {
            if (usedNeedle.isPresent() && !relation.getUsedNeedle().equals(usedNeedle.get())) {
                relation.setUsedNeedle(usedNeedle.get());
                return update(relation);
            }
            return RequestStatus.SUCCESS;
        } else {
            relation = new ReleaseVulnerabilityRelation(releaseId, vulnerabilityId);
            if (usedNeedle.isPresent()) {
                relation.setUsedNeedle(usedNeedle.get());
            }
            return add(relation);
        }
    }

    public RequestStatus addRelationsIfNecessary(String releaseId, List<String> vulnerabilityIds) {
        RequestStatus requestStatus = RequestStatus.SUCCESS;
        for (String vulnerabilityId : vulnerabilityIds) {
            RequestStatus singleOperationStatus = addRelationIfNecessary(releaseId, vulnerabilityId, Optional.empty());
            if (RequestStatus.FAILURE.equals(singleOperationStatus)) {
                requestStatus = RequestStatus.FAILURE;
            }
        }
        return requestStatus;
    }

    public RequestStatus addRelationsIfNecessary(String releaseId, Map<String, List<String>> needlesToVulnerabilityIds) {
        RequestStatus requestStatus = RequestStatus.SUCCESS;
        for (Map.Entry<String, List<String>> needleWithVulnerabilityIds : needlesToVulnerabilityIds.entrySet()) {
            String usedNeedle = needleWithVulnerabilityIds.getKey();
            List<String> vulnerabilityIds = needleWithVulnerabilityIds.getValue();

            for (String vulnerabilityId : vulnerabilityIds) {
                RequestStatus singleOperationStatus = addRelationIfNecessary(releaseId,
                        vulnerabilityId,
                        Optional.ofNullable(usedNeedle));
                if (RequestStatus.FAILURE.equals(singleOperationStatus)) {
                    requestStatus = RequestStatus.FAILURE;
                }
            }
        }
        return requestStatus;
    }

    public List<VulnerabilityDTO> getvulnerabilityDTOByExternalId(Set<String> externalIds, String releaseId) {
        List<VulnerabilityDTO> vulnerabilityDTOs = new ArrayList<>();
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        externalIds.forEach(externalId -> {
            vulnerabilities.add(getByExternalId(Vulnerability.class, externalId));
        });
        vulnerabilities.forEach(vulnerability -> {
            VulnerabilityDTO vulnerabilityDTO = VulnerabilityMapper.createVulnerabilityDTO(vulnerability);
            vulnerabilityDTO.setReleaseVulnerabilityRelation(relationRepo.getRelationByIds(releaseId, vulnerability.getId()));
            vulnerabilityDTOs.add(vulnerabilityDTO);
        });
        return vulnerabilityDTOs;
    }

    public <T extends TBase> RequestStatus update(T element) {
        if (element == null) {
            log.error("cannot update null element");
            return RequestStatus.FAILURE;
        }
        try {
            if (Vulnerability.class.isAssignableFrom(element.getClass())) {
                vulRepo.update(VulnerabilityMapper.setLastUpdate((Vulnerability) element));
            } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(element.getClass())) {
                relationRepo.update((ReleaseVulnerabilityRelation) element);
            } else {
                throw new IllegalArgumentException("unknown type " + element.getClass().getSimpleName());
            }

            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on updating " + element.getClass().getSimpleName() + ": " + e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> RequestStatus delete(T element) {
        if (element == null) {
            log.error("cannot remove null element");
            return RequestStatus.FAILURE;
        }
        try {
            if (Vulnerability.class.isAssignableFrom(element.getClass())) {
                vulRepo.remove((Vulnerability) element);
            } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(element.getClass())) {
                relationRepo.remove((ReleaseVulnerabilityRelation) element);
            } else {
                throw new IllegalArgumentException("unknown type " + element.getClass().getSimpleName());
            }

            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on removing " + element.getClass().getSimpleName() + ": " + e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> Set<String> getAllIds(Class<T> type){
        if (type == null){
            log.error("type cannot be null");
            return null;
        } if (Vulnerability.class.isAssignableFrom(type)) {
            return (Set<String>) vulRepo.getAllIds();
        } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
            return (Set<String>) relationRepo.getAllIds();
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public <T extends TBase> List<T> getAll(Class<T> type) {
        if (type == null) {
            log.error("type cannot be null");
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (List<T>) vulRepo.getAll();
        } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
            return (List<T>) relationRepo.getAll();
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public <T extends TBase> T getById(Class<T> type, String id) {
        if (type == null || StringUtils.isEmpty(id)) {
            log.error("type/id cannot be null " + type + " " + id);
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (T) vulRepo.get(id);
        } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
            return (T) relationRepo.get(id);
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public <T extends TBase> List<T> getByIds(Class<T> type, Collection<String> ids) {
        if (type == null || ids == null) {
            log.error("type/ids cannot be null " + type + " " + ids);
            return ImmutableList.of();
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (List<T>) vulRepo.get(ids);
        } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
            return (List<T>) relationRepo.get(ids);
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public <T extends TBase> Set<String> getAllExternalIds(Class<T> type){
        if (type == null){
            log.error("type cannot be null");
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (Set<String>) vulRepo.getAllExternalIds();
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public List<Vulnerability> getByExternalIdOrVulnerableConfig(String externalId, String vulnerableConfig) {
        return vulRepo.getVulnerabilitiesByExternalIdOrVulnerableConfig(externalId, vulnerableConfig);
    }

    public ReleaseVulnerabilityRelation getRelationByIds(String releaseId, String vulnerabilityId) {
        if (StringUtils.isEmpty(releaseId) || StringUtils.isEmpty(vulnerabilityId)) {
            log.error("releaseId/vulnerabilityId cannot be null " + releaseId + " " + vulnerabilityId);
            return null;
        }
        return relationRepo.getRelationByIds(releaseId, vulnerabilityId);
    }

    public ReleaseVulnerabilityRelation getRelationByIds(ReleaseVulnerabilityRelation relation) {
        return getRelationByIds(relation.getReleaseId(), relation.getVulnerabilityId());
    }

    public List<ReleaseVulnerabilityRelation> getRelationsByReleaseIds(Collection<String> releaseIds) {
        if (releaseIds == null || releaseIds.isEmpty()) {
            log.error("releaseIds cannot be null/empty");
            return null;
        }
        return relationRepo.getRelationsByReleaseIds(releaseIds);
    }

    public <T extends TBase> T getByExternalId(Class<T> type, String externalId) {
        if (type == null || StringUtils.isEmpty(externalId)) {
            log.error("type/externalId cannot be null " + type + " " + externalId);
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (T) vulRepo.getVulnerabilityByExternalid(externalId);
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public <T extends TBase> List<T> getLastUpdated(Class<T> type, int limit) {
        if (type == null) {
            log.error("type cannot be null");
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (List<T>) vulRepo.getVulnerabilitiesByLastUpdate(limit);
        } else {
            return null;
        }
    }

    public VulnerabilityWithReleaseRelations getVulnerabilityWithReleaseRelationsByExternalId(String externalId) {
        Vulnerability vulnerability = vulRepo.getVulnerabilityByExternalid(externalId);
        if (vulnerability != null) {
            List<ReleaseVulnerabilityRelation> relations = relationRepo.getRelationsByVulnerabilityId(vulnerability.getId());
            return new VulnerabilityWithReleaseRelations(vulnerability, relations);
        } else {
            return null;
        }
    }

    public int getTotalVulnerabilityCount() {
        return vulRepo.getDocumentCount();
    }

    public List<ReleaseVulnerabilityRelation> getReleaseVulnerabilityRelationsByReleaseId(String releaseId) {
        return relationRepo.getRelationsByReleaseIds(Sets.newHashSet(releaseId));
    }

    public void validateVulnerability(Vulnerability vulnerability) throws SW360Exception {
        if (CommonUtils.isNullEmptyOrWhitespace(vulnerability.getExternalId())) {
            throw new SW360Exception("Invalid vulnerability: missing property 'externalId'.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }

        if (vulnerability.getCveReferences() != null) {
            for (CVEReference cveReference : vulnerability.getCveReferences()) {
                validateCVEReference(cveReference);
            }
        }

        if (vulnerability.getVendorAdvisories() != null) {
            for (VendorAdvisory va : vulnerability.getVendorAdvisories()) {
                validateVendorAdvisory(va);
            }
        }
    }

    public void validateReleaseVulnerabilityRelation(ReleaseVulnerabilityRelation releaseVulnerabilityRelation)
            throws SW360Exception {

        if (CommonUtils.isNullEmptyOrWhitespace(releaseVulnerabilityRelation.getReleaseId())) {
            throw new SW360Exception("Invalid ReleaseVulnerabilityRelation: property 'releaseId' cannot be null, empty or whitespace.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }

        if (releaseVulnerabilityRelation.getVerificationStateInfo() != null) {
            for (VerificationStateInfo vsi : releaseVulnerabilityRelation.getVerificationStateInfo()) {
                validateVerificationStateInfo(vsi);
            }
        }
    }

    private void validateVerificationStateInfo(VerificationStateInfo verificationStateInfo) throws SW360Exception {
        if (CommonUtils.isNullEmptyOrWhitespace(verificationStateInfo.getCheckedBy())) {
            throw new SW360Exception("Invalid VerificationStateInfo: property 'checkedBy' cannot be null, empty or whitespace.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }

        if (CommonUtils.isNullEmptyOrWhitespace(verificationStateInfo.getCheckedOn())) {
            throw new SW360Exception("Invalid VerificationStateInfo: property 'checkedOn' cannot be null, empty or whitespace.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }

        if (verificationStateInfo.getVerificationState() == null) {
            throw new SW360Exception("Invalid VerificationStateInfo: property 'verificationState' cannot be null, empty or whitespace.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }
    }

    private void validateCVEReference(CVEReference cveReference) throws SW360Exception {
        if (CommonUtils.isNullEmptyOrWhitespace(cveReference.getYear())) {
            throw new SW360Exception("Invalid CVEReference: property 'year' cannot be null, empty or whitespace.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }
        try {
            int year = Integer.parseInt(cveReference.getYear());
            if (year <= 0) {
                throw new SW360Exception("Invalid CVEReference: property 'year' should be a valid year.")
                        .setErrorCode(HttpStatus.SC_BAD_REQUEST);
            }
        } catch (NumberFormatException nfe) {
            throw new SW360Exception("Invalid CVEReference: property 'year' should be a valid year.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }
        if (CommonUtils.isNullEmptyOrWhitespace(cveReference.getNumber())) {
            throw new SW360Exception("Invalid CVEReference: property 'number' cannot be null, empty or whitespace.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }
        try {
            Integer.parseInt(cveReference.getNumber());
        } catch (NumberFormatException nfe) {
            throw new SW360Exception("Invalid CVEReference: property 'number' should be a valid number.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }
    }

    private void validateVendorAdvisory(VendorAdvisory vendorAdvisory) throws SW360Exception {
        if (CommonUtils.isNullEmptyOrWhitespace(vendorAdvisory.getVendor())) {
            throw new SW360Exception("Invalid VendorAdvisory: property 'vendor' cannot be null, empty or whitespace.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }

        if (CommonUtils.isNullEmptyOrWhitespace(vendorAdvisory.getName())) {
            throw new SW360Exception("Invalid VendorAdvisory: property 'name' cannot be null, empty or whitespace.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }

        if (CommonUtils.isNullEmptyOrWhitespace(vendorAdvisory.getUrl())) {
            throw new SW360Exception("Invalid VendorAdvisory: property 'url' cannot be null, empty or whitespace.")
                    .setErrorCode(HttpStatus.SC_BAD_REQUEST);
        }
    }
}
