/*
 * Copyright Siemens AG, 2016.
 * Copyright (c) Bosch Software Innovations GmbH 2016-2017.
 * Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.vulnerabilities;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.MoreObjects;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

import org.eclipse.sw360.datahandler.common.CommonUtils;
import org.eclipse.sw360.datahandler.common.DatabaseSettings;
import org.eclipse.sw360.datahandler.common.SW360Assert;
import org.eclipse.sw360.datahandler.common.SW360Utils;
import org.eclipse.sw360.datahandler.db.ComponentDatabaseHandler;
import org.eclipse.sw360.datahandler.db.ProjectDatabaseHandler;
import org.eclipse.sw360.datahandler.permissions.PermissionUtils;
import org.eclipse.sw360.datahandler.thrift.*;
import org.eclipse.sw360.datahandler.thrift.components.Component;
import org.eclipse.sw360.datahandler.thrift.components.Release;
import org.eclipse.sw360.datahandler.thrift.components.ReleaseLinkJSON;
import org.eclipse.sw360.datahandler.thrift.projects.Project;
import org.eclipse.sw360.datahandler.thrift.users.RequestedAction;
import org.eclipse.sw360.datahandler.thrift.users.User;
import org.eclipse.sw360.datahandler.thrift.users.UserGroup;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.*;
import org.eclipse.sw360.vulnerabilities.common.VulnerabilityMapper;
import org.eclipse.sw360.vulnerabilities.db.VulnerabilityDatabaseHandler;

import org.apache.commons.lang.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.thrift.TException;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

/**
 * Implementation of the Thrift service
 *
 * @author stefan.jaeger@evosoft.com
 */
public class VulnerabilityHandler implements VulnerabilityService.Iface {

    private final static Logger log = LogManager.getLogger(VulnerabilityHandler.class);


    private final VulnerabilityDatabaseHandler dbHandler;
    private final ComponentDatabaseHandler compHandler;
    private final ProjectDatabaseHandler projectDatabaseHandler;

    public VulnerabilityHandler() throws IOException, SW360Exception {
        dbHandler = new VulnerabilityDatabaseHandler();
        compHandler = new ComponentDatabaseHandler(DatabaseSettings.getConfiguredHttpClient(), DatabaseSettings.getConfiguredClient(), DatabaseSettings.COUCH_DB_DATABASE, DatabaseSettings.COUCH_DB_ATTACHMENTS);
        projectDatabaseHandler = new ProjectDatabaseHandler(DatabaseSettings.getConfiguredHttpClient(), DatabaseSettings.getConfiguredClient(), DatabaseSettings.COUCH_DB_DATABASE, DatabaseSettings.COUCH_DB_ATTACHMENTS);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByReleaseId(String releaseId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }

        return getVulsByReleaseIds(Collections.singletonList(releaseId), user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByComponentId(String componentId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }
        List<Release> releases = compHandler.getReleasesFromComponentId(componentId, user);
        if (releases == null || releases.size() == 0) {
            return Collections.emptyList();
        }

        List<String> ids = releases.stream().map(Release::getId).collect(Collectors.toList());
        return getVulsByReleaseIds(ids, user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByProjectId(String projectId, User user) throws TException {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true);
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }
        Set<String> releaseIds = new HashSet<>();
        Project project = projectDatabaseHandler.getProjectById(projectId, user);

        List<ReleaseLinkJSON> releaseLinkJSONS = null;
        if (project.getReleaseRelationNetwork() != null) {
            try {
                releaseLinkJSONS = objectMapper.readValue(project.getReleaseRelationNetwork(), new TypeReference<>() {
                });
            } catch (JsonProcessingException e) {
                log.error(e.getMessage());
            }
        }
        if (releaseLinkJSONS != null) {
            for (ReleaseLinkJSON releaseLink : releaseLinkJSONS) {
                releaseIds.add(releaseLink.getReleaseId());
                getSubReleaseIds(releaseLink.getReleaseLink(), releaseIds);
            }
        }
        return getVulsByReleaseIds(releaseIds, user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByReleaseIdWithoutIncorrect(String releaseId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }

        return getVulsByReleaseIdsWithoutIncorrect(Collections.singletonList(releaseId), user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByComponentIdWithoutIncorrect(String componentId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }
        List<Release> releases = compHandler.getReleasesFromComponentId(componentId, user);

        List<String> ids = releases.stream().map(Release::getId).collect(Collectors.toList());
        return getVulsByReleaseIdsWithoutIncorrect(ids, user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByProjectIdWithoutIncorrect(String projectId, User user) throws TException {
        Set<String> releaseIds = new HashSet<>();
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }
        Project project = projectDatabaseHandler.getProjectById(projectId, user);
        if (!SW360Utils.getReleaseIdsLinkedWithProject(project).isEmpty()) {
            releaseIds = SW360Utils.getReleaseIdsLinkedWithProject(project);
        }
        return getVulsByReleaseIdsWithoutIncorrect(releaseIds, user);
    }

    private List<VulnerabilityDTO> getVulsByReleaseIds(Collection<String> releaseIds, User user) {
        List<ReleaseVulnerabilityRelation> relations = getReleaseVulnerabilityRelationByReleaseIds(releaseIds);
        return getDtosFromRelations(relations, user);
    }

    private List<VulnerabilityDTO> getVulsByReleaseIdsWithoutIncorrect(Collection<String> releaseIds, User user) {
        List<ReleaseVulnerabilityRelation> relations = getReleaseVulnerabilityRelationByReleaseIds(releaseIds);
        List<ReleaseVulnerabilityRelation> filteredRelations = relations.stream()
                .filter(VulnerabilityHandler::releaseVulnerabilityRelationIsNotIncorrect)
                .collect(Collectors.toList());
        return getDtosFromRelations(filteredRelations, user);
    }

    private List<ReleaseVulnerabilityRelation> getReleaseVulnerabilityRelationByReleaseIds(Collection<String> releaseIds) {
        List<ReleaseVulnerabilityRelation> relations = dbHandler.getRelationsByReleaseIds(releaseIds);
        return MoreObjects.firstNonNull(relations, Collections.emptyList());
    }

    private static boolean releaseVulnerabilityRelationIsNotIncorrect(ReleaseVulnerabilityRelation relation) {
        if (!relation.isSetVerificationStateInfo()) {
            return true;
        }
        List<VerificationStateInfo> stateHistory = relation.getVerificationStateInfo();
        VerificationStateInfo currentState = stateHistory.get(stateHistory.size() - 1);
        return !VerificationState.INCORRECT.equals(currentState.getVerificationState());
    }

    private List<VulnerabilityDTO> getDtosFromRelations(List<ReleaseVulnerabilityRelation> relations, User user) {
        Set<String> vulnerabilityIds = relations.stream()
                .map(ReleaseVulnerabilityRelation::getVulnerabilityId)
                .collect(Collectors.toSet());

        List<Vulnerability> vulnerabilities = dbHandler.getByIds(Vulnerability.class, vulnerabilityIds);
        Map<String, Vulnerability> vulnerabilityMap= ThriftUtils.getIdMap(vulnerabilities);

        LoadingCache<String, Release> releaseCache = makeReleaseCache(user);
        LoadingCache<String, Component> componentCache = makeComponentCache(user);

        return relations.stream()
                .map(relation -> getDtoFromRelation(relation, vulnerabilityMap.get(relation.getVulnerabilityId())))
                .map(dto -> enrichVulnerabilityDTO(dto, componentCache, releaseCache))
                .collect(Collectors.toList());
    }

    private VulnerabilityDTO getDtoFromRelation(ReleaseVulnerabilityRelation relation, Vulnerability vulnerability) {
        VulnerabilityDTO dto = VulnerabilityMapper.createVulnerabilityDTO(vulnerability);
        dto.setIntReleaseId(relation.getReleaseId());
        dto.setReleaseVulnerabilityRelation(relation);
        if (relation.isSetMatchedBy()) {
            dto.setMatchedBy(relation.getMatchedBy());
        }
        if (relation.isSetUsedNeedle()) {
            dto.setUsedNeedle(relation.getUsedNeedle());
        }
        return dto;
    }

    private VulnerabilityDTO enrichVulnerabilityDTO(VulnerabilityDTO dto, LoadingCache<String, Component> componentCache, LoadingCache<String, Release> releaseCache) {
        String releaseId = dto.getIntReleaseId();
        try {
            Release release = releaseCache.get(releaseId);
            if (release != null) {
                dto.setIntComponentId(release.getComponentId());

                String releaseName = "";
                if (!StringUtils.isEmpty(release.getName())) {
                    releaseName = release.getName() + " ";
                    dto.setIntComponentName(release.getName());
                } else {
                    Component component = componentCache.get(release.getComponentId());
                    if (component != null) {
                        releaseName = component.getName() + " ";
                        dto.setIntComponentName(component.getName());
                    }
                }
                dto.setIntReleaseName(releaseName + release.getVersion());
            }
        } catch (ExecutionException e) {
            log.error(e);
        }
        return dto;
    }

    private LoadingCache<String, Release> makeReleaseCache(User user) {
        return CacheBuilder.newBuilder()
                .build(new CacheLoader<String, Release>() {
                    public Release load(String key) throws SW360Exception {
                        log.error("loading " + key + " release from db.");
                        return compHandler.getRelease(key, user);
                    }
                });
    }

    private LoadingCache<String, Component> makeComponentCache(User user) {
        return CacheBuilder.newBuilder()
                .build(new CacheLoader<String, Component>() {
                    public Component load(String key) throws SW360Exception {
                        log.error("loading " + key + " component from db.");
                        return compHandler.getComponent(key, user);
                    }
                });
    }

    @Override
    public List<ProjectVulnerabilityRating> getProjectVulnerabilityRatingByProjectId(String projectId, User user) {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return null;
        }
        return projectDatabaseHandler.getProjectVulnerabilityRatingByProjectId(projectId);
    }

    @Override
    public RequestStatus updateProjectVulnerabilityRating(ProjectVulnerabilityRating link, User user) {
        Project project = null;
        try {
            project = projectDatabaseHandler.getProjectById(link.getProjectId(), user);
        } catch (SW360Exception e) {
            log.error("An exception occurred when fetching the project with id " + link.getProjectId() + " from the database.", e);
            return RequestStatus.FAILURE;
        }
        if (PermissionUtils.makePermission(project, user).isActionAllowed(RequestedAction.WRITE)) {
            return projectDatabaseHandler.updateProjectVulnerabilityRating(link);
        }
        return RequestStatus.FAILURE;
    }

    @Override
    public ReleaseVulnerabilityRelation getRelationByIds(String releaseId, String vulnerabilityId, User user) {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return null;
        }
        return dbHandler.getRelationByIds(releaseId, vulnerabilityId);
    }

    @Override
    public Vulnerability getVulnerabilityByExternalId(String externalId, User user) throws SW360Exception {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            throw new SW360Exception("Access Denied").setErrorCode(403);
        }
        Vulnerability vulnerabilityByExternalId = dbHandler.getByExternalId(Vulnerability.class, externalId);
        SW360Assert.assertNotNull(vulnerabilityByExternalId);

        return vulnerabilityByExternalId;
    }

    @Override
    public VulnerabilityWithReleaseRelations getVulnerabilityWithReleaseRelationsByExternalId(String externalId,
            User user) throws SW360Exception {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            throw new SW360Exception("Access Denied").setErrorCode(403);
        }
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelationsByExternalId = dbHandler
                .getVulnerabilityWithReleaseRelationsByExternalId(externalId);

        SW360Assert.assertNotNull(vulnerabilityWithReleaseRelationsByExternalId);

        return vulnerabilityWithReleaseRelationsByExternalId;
    }

    @Override
    public List<Vulnerability> getVulnerabilitiesByExternalIdOrConfiguration(String externalId, String vulnerableConfiguration, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return null;
        }
        return dbHandler.getByExternalIdOrVulnerableConfig(externalId, vulnerableConfiguration);
    }

    @Override
    public RequestStatus updateReleaseVulnerabilityRelation(ReleaseVulnerabilityRelation relation, User user) {
        Set<UserGroup> allSecRoles = !CommonUtils.isNullOrEmptyMap(user.getSecondaryDepartmentsAndRoles())
                ? user.getSecondaryDepartmentsAndRoles().entrySet().stream().flatMap(entry -> entry.getValue().stream())
                        .collect(Collectors.toSet())
                : new HashSet<UserGroup>();

        if (!(PermissionUtils.isUserAtLeast(UserGroup.SECURITY_ADMIN, user)
                || PermissionUtils.isUserAtLeastDesiredRoleInSecondaryGroup(UserGroup.SECURITY_ADMIN, allSecRoles))) {
            return RequestStatus.FAILURE;
        }
        return dbHandler.update(relation);
    }

    @Override
    public List<Vulnerability> getVulnerabilities(User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }

        return dbHandler.getAll(Vulnerability.class);
    }

    @Override
    public List<Vulnerability> getLatestVulnerabilities(User user, int limit) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }

        return dbHandler.getLastUpdated(Vulnerability.class, limit);
    }

    @Override
    public int getTotalVulnerabilityCount(User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return 0;
        }

        return dbHandler.getTotalVulnerabilityCount();
    }

    @Override
    public List<ReleaseVulnerabilityRelation> getReleaseVulnerabilityRelationsByReleaseId(String releaseId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return new ArrayList<>();
        }
        return dbHandler.getReleaseVulnerabilityRelationsByReleaseId(releaseId);
    }

    @Override
    public RequestStatus addVulnerability(Vulnerability vulnerability, User user) throws SW360Exception {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return RequestStatus.ACCESS_DENIED;
        }
        dbHandler.validateVulnerability(vulnerability);
        return dbHandler.add(vulnerability);
    }

    @Override
    public RequestStatus updateVulnerability(Vulnerability vulnerability, User user) throws SW360Exception {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return RequestStatus.ACCESS_DENIED;
        }
        dbHandler.validateVulnerability(vulnerability);
        return dbHandler.update(vulnerability);
    }

    @Override
    public RequestStatus deleteVulnerability(Vulnerability vulnerability, User user) throws SW360Exception {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return RequestStatus.ACCESS_DENIED;
        }

        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations =
                getVulnerabilityWithReleaseRelationsByExternalId(vulnerability.getExternalId(), user);

        if (!CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
            return dbHandler.delete(vulnerability);
        } else {
            List<Release> releasesInRelation = new ArrayList<>();
            Set<String> releaseIdsInRelation = vulnerabilityWithReleaseRelations.getReleaseRelation().stream()
                    .map(ReleaseVulnerabilityRelation::getReleaseId)
                    .collect(Collectors.toSet());

            releaseIdsInRelation.forEach(releaseId -> {
                try {
                    Release release = compHandler.getRelease(releaseId, user);
                    if (release != null) {
                        releasesInRelation.add(release);
                    }
                } catch (TException e) {
                    log.error("Error when get release: " + releaseId + ". " + e.getMessage());
                }
            });

            if (releasesInRelation.isEmpty()) {
                return dbHandler.delete(vulnerability);
            } else {
                return RequestStatus.IN_USE;
            }
        }
    }

    @Override
    public RequestStatus addReleaseVulnerabilityRelation(ReleaseVulnerabilityRelation releaseVulnerabilityRelation,
            User user) throws SW360Exception {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return RequestStatus.ACCESS_DENIED;
        }
        dbHandler.validateReleaseVulnerabilityRelation(releaseVulnerabilityRelation);
        return dbHandler.add(releaseVulnerabilityRelation);
    }

    @Override
    public RequestStatus deleteReleaseVulnerabilityRelation(ReleaseVulnerabilityRelation releaseVulnerabilityRelation,
            User user) throws SW360Exception {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return RequestStatus.ACCESS_DENIED;
        }
        return dbHandler.delete(releaseVulnerabilityRelation);
    }

    @Override
    public Vulnerability getById(String id) throws TException {
        Vulnerability vulnerability = dbHandler.getById(Vulnerability.class,id);
        return vulnerability;
    }

    @Override
    public Vulnerability getByExternalId(String externalId) throws TException {
        Vulnerability vulnerabilityByExternalId = dbHandler.getByExternalId(Vulnerability.class, externalId);
        return vulnerabilityByExternalId;
    }

    @Override
    public List<ProjectVulnerabilityRating> getProjectVulnerabilityRatingsByReleaseId(String releaseId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return new ArrayList<>();
        }
        return projectDatabaseHandler.getProjectVulnerabilityRatingsByReleaseId(releaseId);
    }

    private void getSubReleaseIds(List<ReleaseLinkJSON> releaseLinks, Set<String> releaseIds) throws TException {
        for (ReleaseLinkJSON release : releaseLinks) {
            releaseIds.add(release.getReleaseId());
            getSubReleaseIds(release.getReleaseLink(), releaseIds);
        }
    }
}
