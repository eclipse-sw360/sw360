/*
 * Copyright Siemens AG, 2016.
 * Copyright (c) Bosch Software Innovations GmbH 2016-2017.
 * Part of the SW360 Portal Project.
 *
 * SPDX-License-Identifier: EPL-1.0
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.eclipse.sw360.vulnerabilities;

import com.google.common.base.MoreObjects;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

import org.eclipse.sw360.datahandler.common.DatabaseSettings;
import org.eclipse.sw360.datahandler.db.ComponentDatabaseHandler;
import org.eclipse.sw360.datahandler.db.ProjectDatabaseHandler;
import org.eclipse.sw360.datahandler.permissions.PermissionUtils;
import org.eclipse.sw360.datahandler.thrift.*;
import org.eclipse.sw360.datahandler.thrift.components.Component;
import org.eclipse.sw360.datahandler.thrift.components.Release;
import org.eclipse.sw360.datahandler.thrift.projects.Project;
import org.eclipse.sw360.datahandler.thrift.users.RequestedAction;
import org.eclipse.sw360.datahandler.thrift.users.User;
import org.eclipse.sw360.datahandler.thrift.users.UserGroup;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.*;
import org.eclipse.sw360.vulnerabilities.common.VulnerabilityMapper;
import org.eclipse.sw360.vulnerabilities.db.VulnerabilityDatabaseHandler;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.apache.thrift.TException;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

import static org.apache.log4j.Logger.getLogger;

/**
 * Implementation of the Thrift service
 *
 * @author stefan.jaeger@evosoft.com
 */
public class VulnerabilityHandler implements VulnerabilityService.Iface {

    private final static Logger log = getLogger(VulnerabilityHandler.class);


    private final VulnerabilityDatabaseHandler dbHandler;
    private final ComponentDatabaseHandler compHandler;
    private final ProjectDatabaseHandler projectDatabaseHandler;

    public VulnerabilityHandler() throws IOException, SW360Exception {
        dbHandler = new VulnerabilityDatabaseHandler();
        compHandler = new ComponentDatabaseHandler(DatabaseSettings.getConfiguredHttpClient(), DatabaseSettings.COUCH_DB_DATABASE, DatabaseSettings.COUCH_DB_ATTACHMENTS);
        projectDatabaseHandler = new ProjectDatabaseHandler(DatabaseSettings.getConfiguredHttpClient(), DatabaseSettings.COUCH_DB_DATABASE, DatabaseSettings.COUCH_DB_ATTACHMENTS);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByReleaseId(String releaseId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }

        return getVulsByReleaseIds(Collections.singletonList(releaseId), user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByComponentId(String componentId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }
        List<Release> releases = compHandler.getReleasesFromComponentId(componentId, user);
        if (releases == null || releases.size() == 0) {
            return Collections.emptyList();
        }

        List<String> ids = releases.stream().map(Release::getId).collect(Collectors.toList());
        return getVulsByReleaseIds(ids, user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByProjectId(String projectId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }
        Set<String> releaseIds = projectDatabaseHandler.getProjectById(projectId, user).getReleaseIdToUsage().keySet();
        return getVulsByReleaseIds(releaseIds, user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByReleaseIdWithoutIncorrect(String releaseId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }

        return getVulsByReleaseIdsWithoutIncorrect(Collections.singletonList(releaseId), user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByComponentIdWithoutIncorrect(String componentId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }
        List<Release> releases = compHandler.getReleasesFromComponentId(componentId, user);

        List<String> ids = releases.stream().map(Release::getId).collect(Collectors.toList());
        return getVulsByReleaseIdsWithoutIncorrect(ids, user);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByProjectIdWithoutIncorrect(String projectId, User user) throws TException {
        Set<String> releaseIds = new HashSet<>();
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }
        Project project = projectDatabaseHandler.getProjectById(projectId, user);
        if (project.isSetReleaseIdToUsage()) {
            releaseIds = project.getReleaseIdToUsage().keySet();
        }
        return getVulsByReleaseIdsWithoutIncorrect(releaseIds, user);
    }

    private List<VulnerabilityDTO> getVulsByReleaseIds(Collection<String> releaseIds, User user) {
        List<ReleaseVulnerabilityRelation> relations = getReleaseVulnerabilityRelationByReleaseIds(releaseIds);
        return getDtosFromRelations(relations, user);
    }

    private List<VulnerabilityDTO> getVulsByReleaseIdsWithoutIncorrect(Collection<String> releaseIds, User user) {
        List<ReleaseVulnerabilityRelation> relations = getReleaseVulnerabilityRelationByReleaseIds(releaseIds);
        List<ReleaseVulnerabilityRelation> filteredRelations = relations.stream()
                .filter(VulnerabilityHandler::releaseVulnerabilityRelationIsNotIncorrect)
                .collect(Collectors.toList());
        return getDtosFromRelations(filteredRelations, user);
    }

    private List<ReleaseVulnerabilityRelation> getReleaseVulnerabilityRelationByReleaseIds(Collection<String> releaseIds) {
        List<ReleaseVulnerabilityRelation> relations = dbHandler.getRelationsByReleaseIds(releaseIds);
        return MoreObjects.firstNonNull(relations, Collections.emptyList());
    }

    private static boolean releaseVulnerabilityRelationIsNotIncorrect(ReleaseVulnerabilityRelation relation) {
        if (!relation.isSetVerificationStateInfo()) {
            return true;
        }
        List<VerificationStateInfo> stateHistory = relation.getVerificationStateInfo();
        VerificationStateInfo currentState = stateHistory.get(stateHistory.size() - 1);
        return !VerificationState.INCORRECT.equals(currentState.getVerificationState());
    }

    private List<VulnerabilityDTO> getDtosFromRelations(List<ReleaseVulnerabilityRelation> relations, User user) {
        Set<String> vulnerabilityIds = relations.stream()
                .map(ReleaseVulnerabilityRelation::getVulnerabilityId)
                .collect(Collectors.toSet());

        List<Vulnerability> vulnerabilities = dbHandler.getByIds(Vulnerability.class, vulnerabilityIds);
        Map<String, Vulnerability> vulnerabilityMap= ThriftUtils.getIdMap(vulnerabilities);

        LoadingCache<String, Release> releaseCache = makeReleaseCache(user);
        LoadingCache<String, Component> componentCache = makeComponentCache(user);

        return relations.stream()
                .map(relation -> getDtoFromRelation(relation, vulnerabilityMap.get(relation.getVulnerabilityId())))
                .map(dto -> enrichVulnerabilityDTO(dto, componentCache, releaseCache))
                .collect(Collectors.toList());
    }

    private VulnerabilityDTO getDtoFromRelation(ReleaseVulnerabilityRelation relation, Vulnerability vulnerability) {
        VulnerabilityDTO dto = VulnerabilityMapper.createVulnerabilityDTO(vulnerability);
        dto.setIntReleaseId(relation.getReleaseId());
        dto.setReleaseVulnerabilityRelation(relation);
        if (relation.isSetMatchedBy()) {
            dto.setMatchedBy(relation.getMatchedBy());
        }
        if (relation.isSetUsedNeedle()) {
            dto.setUsedNeedle(relation.getUsedNeedle());
        }
        return dto;
    }

    private VulnerabilityDTO enrichVulnerabilityDTO(VulnerabilityDTO dto, LoadingCache<String, Component> componentCache, LoadingCache<String, Release> releaseCache) {
        String releaseId = dto.getIntReleaseId();
        try {
            Release release = releaseCache.get(releaseId);
            if (release != null) {
                dto.setIntComponentId(release.getComponentId());

                String releaseName = "";
                if (!StringUtils.isEmpty(release.getName())) {
                    releaseName = release.getName() + " ";
                    dto.setIntComponentName(release.getName());
                } else {
                    Component component = componentCache.get(release.getComponentId());
                    if (component != null) {
                        releaseName = component.getName() + " ";
                        dto.setIntComponentName(component.getName());
                    }
                }
                dto.setIntReleaseName(releaseName + release.getVersion());
            }
        } catch (ExecutionException e) {
            log.error(e);
        }
        return dto;
    }

    private LoadingCache<String, Release> makeReleaseCache(User user) {
        return CacheBuilder.newBuilder()
                .build(new CacheLoader<String, Release>() {
                    public Release load(String key) throws SW360Exception {
                        log.error("loading " + key + " release from db.");
                        return compHandler.getRelease(key, user);
                    }
                });
    }

    private LoadingCache<String, Component> makeComponentCache(User user) {
        return CacheBuilder.newBuilder()
                .build(new CacheLoader<String, Component>() {
                    public Component load(String key) throws SW360Exception {
                        log.error("loading " + key + " component from db.");
                        return compHandler.getComponent(key, user);
                    }
                });
    }

    @Override
    public List<ProjectVulnerabilityRating> getProjectVulnerabilityRatingByProjectId(String projectId, User user) {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return null;
        }
        return projectDatabaseHandler.getProjectVulnerabilityRatingByProjectId(projectId);
    }

    @Override
    public RequestStatus updateProjectVulnerabilityRating(ProjectVulnerabilityRating link, User user) {
        Project project = null;
        try {
            project = projectDatabaseHandler.getProjectById(link.getProjectId(), user);
        } catch (SW360Exception e) {
            log.error("An exception occurred when fetching the project with id " + link.getProjectId() + " from the database.", e);
            return RequestStatus.FAILURE;
        }
        if (PermissionUtils.makePermission(project, user).isActionAllowed(RequestedAction.WRITE)) {
            return projectDatabaseHandler.updateProjectVulnerabilityRating(link);
        }
        return RequestStatus.FAILURE;
    }

    @Override
    public ReleaseVulnerabilityRelation getRelationByIds(String releaseId, String vulnerabilityId, User user) {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return null;
        }
        return dbHandler.getRelationByIds(releaseId, vulnerabilityId);
    }

    @Override
    public Vulnerability getVulnerabilityByExternalId(String externalId, User user) {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return null;
        }
        return dbHandler.getByExternalId(Vulnerability.class, externalId);
    }

    @Override
    public VulnerabilityWithReleaseRelations getVulnerabilityWithReleaseRelationsByExternalId(String externalId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return null;
        }
        return dbHandler.getVulnerabilityWithReleaseRelationsByExternalId(externalId);
    }

    @Override
    public List<Vulnerability> getVulnerabilitiesByExternalIdOrConfiguration(String externalId, String vulnerableConfiguration, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return null;
        }
        return dbHandler.getByExternalIdOrVulnerableConfig(externalId, vulnerableConfiguration);
    }

    @Override
    public RequestStatus updateReleaseVulnerabilityRelation(ReleaseVulnerabilityRelation relation, User user) {
        if (!PermissionUtils.isUserAtLeast(UserGroup.SECURITY_ADMIN, user)) {
            return RequestStatus.FAILURE;
        }
        return dbHandler.update(relation);
    }

    @Override
    public List<Vulnerability> getVulnerabilities(User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }

        return dbHandler.getAll(Vulnerability.class);
    }

    @Override
    public List<Vulnerability> getLatestVulnerabilities(User user, int limit) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return Collections.emptyList();
        }

        return dbHandler.getLastUpdated(Vulnerability.class, limit);
    }

    @Override
    public int getTotalVulnerabilityCount(User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return 0;
        }

        return dbHandler.getTotalVulnerabilityCount();
    }

    @Override
    public List<ReleaseVulnerabilityRelation> getReleaseVulnerabilityRelationsByReleaseId(String releaseId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return new ArrayList<>();
        }
        return dbHandler.getReleaseVulnerabilityRelationsByReleaseId(releaseId);
    }

    @Override
    public List<ProjectVulnerabilityRating> getProjectVulnerabilityRatingsByReleaseId(String releaseId, User user) throws TException {
        if (!PermissionUtils.isUserAtLeast(UserGroup.USER, user)) {
            return new ArrayList<>();
        }
        return projectDatabaseHandler.getProjectVulnerabilityRatingsByReleaseId(releaseId);
    }
}
