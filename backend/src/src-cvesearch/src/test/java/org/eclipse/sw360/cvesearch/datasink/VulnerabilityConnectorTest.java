/*
 * Copyright (c) Bosch Software Innovations GmbH 2016.
 * Part of the SW360 Portal Project.
 *
 * SPDX-License-Identifier: EPL-1.0
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.eclipse.sw360.cvesearch.datasink;

import org.eclipse.sw360.datahandler.thrift.RequestStatus;
import org.eclipse.sw360.datahandler.thrift.cvesearch.UpdateType;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import org.eclipse.sw360.vulnerabilities.db.VulnerabilityDatabaseHandler;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.*;

import static org.hamcrest.Matchers.is;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;


@RunWith(MockitoJUnitRunner.class)
public class VulnerabilityConnectorTest {
    Map<UpdateType, List<Vulnerability>> statusToVulnerabilityMap;

    @Mock
    VulnerabilityDatabaseHandler vulnerabilityDatabaseHandler;

    @InjectMocks
    VulnerabilityConnector vulnerabilityConnector;

    @Before
    public void setUp() throws Exception{
        statusToVulnerabilityMap = new HashMap<>();
        for (UpdateType updateType: UpdateType.values()){
            statusToVulnerabilityMap.put(updateType, new ArrayList<>());
        }
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdOldVulnerability() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv1").setExternalId("eid");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(v1);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertThat(resultMap.get(UpdateType.OLD).get(0).getId(), is("idv1"));
        assertThat(resultMap.get(UpdateType.NEW), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.UPDATED), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.FAILED), is(Collections.EMPTY_LIST));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdNewVulnerability() throws Exception {
        Vulnerability v1 = new Vulnerability().setId("idv1").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(null);
        when(vulnerabilityDatabaseHandler.add(v1)).thenReturn(RequestStatus.SUCCESS);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v1, statusToVulnerabilityMap);

        assertThat(resultMap.get(UpdateType.NEW).get(0).getId(), is("idv1"));
        assertThat(resultMap.get(UpdateType.OLD), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.UPDATED), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.FAILED), is(Collections.EMPTY_LIST));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdUpdateVulnerability() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv1").setExternalId("eid");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(v1);
        when(vulnerabilityDatabaseHandler.update(v1)).thenReturn(RequestStatus.SUCCESS);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertThat(resultMap.get(UpdateType.UPDATED).get(0).getId(), is("idv1"));
        assertThat(resultMap.get(UpdateType.UPDATED).get(0).getLastExternalUpdate(), is("2000-01-01"));
        assertThat(resultMap.get(UpdateType.NEW), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.OLD), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.FAILED), is(Collections.EMPTY_LIST));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdFailAdd() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv1").setExternalId("eid");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(v1);
        when(vulnerabilityDatabaseHandler.update(v1)).thenReturn(RequestStatus.FAILURE);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertThat(resultMap.get(UpdateType.FAILED).get(0).getId(), is("idv2"));
        assertThat(resultMap.get(UpdateType.NEW), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.OLD), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.UPDATED), is(Collections.EMPTY_LIST));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdFailUpdate() throws Exception {
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(null);
        when(vulnerabilityDatabaseHandler.add(v2)).thenReturn(RequestStatus.FAILURE);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertThat(resultMap.get(UpdateType.FAILED).get(0).getId(), is("idv2"));
        assertThat(resultMap.get(UpdateType.NEW), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.OLD), is(Collections.EMPTY_LIST));
        assertThat(resultMap.get(UpdateType.UPDATED), is(Collections.EMPTY_LIST));
    }

    @Test
    public void testaddOrUpdateVulnerabilitiesAndSetIds(){
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv1").setExternalId("eid1");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid2");
        Vulnerability v3= new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv3").setExternalId("eid1");
        Vulnerability v4 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv4").setExternalId("eid2");
        Vulnerability v5 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv5").setExternalId("eid5");

        List<Vulnerability> vulnerabilityList = Arrays.asList(v3,v4,v5);

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid1")).thenReturn(v1);
        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid2")).thenReturn(v2);
        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid5")).thenReturn(null);
        when(vulnerabilityDatabaseHandler.add(v5)).thenReturn(RequestStatus.SUCCESS);
        when(vulnerabilityDatabaseHandler.update(v1)).thenReturn(RequestStatus.SUCCESS);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilitiesAndSetIds(vulnerabilityList);

        assertThat(resultMap.get(UpdateType.UPDATED).get(0).getId(), is("idv1"));
        assertThat(resultMap.get(UpdateType.NEW).get(0).getId(), is("idv5"));
        assertThat(resultMap.get(UpdateType.OLD).get(0).getId(), is("idv2"));
        assertThat(resultMap.get(UpdateType.FAILED), is(Collections.EMPTY_LIST));
    }

    @Test
    public void testIsMoreRecentEmpty() throws Exception {
        Vulnerability v1 = new Vulnerability();
        Vulnerability v2 = new Vulnerability();
        assertThat(vulnerabilityConnector.isMoreRecent(v1, v2), is(true));
    }

    @Test
    public void testIsMoreRecentFirstNull() throws Exception {
        Vulnerability v1 = new Vulnerability();
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2016");
        assertThat(vulnerabilityConnector.isMoreRecent(v1, v2), is(true));
    }

    @Test
    public void testIsMoreRecentSecondNull() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2016");
        Vulnerability v2 = new Vulnerability();
        assertThat(vulnerabilityConnector.isMoreRecent(v1, v2), is(true));
    }

    @Test
    public void testIsMoreRecentFirstEmpty() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2016");
        assertThat(vulnerabilityConnector.isMoreRecent(v1, v2), is(true));
    }

    @Test
    public void testIsMoreRecentSecondEmpty() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2016");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("");
        assertThat(vulnerabilityConnector.isMoreRecent(v1, v2), is(true));
    }

    @Test
    public void testIsMoreRecentFirstOlder() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2015");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2016");
        assertThat(vulnerabilityConnector.isMoreRecent(v1, v2), is(false));
    }

    @Test
    public void testIsMoreRecentSecondOlder() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2016");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2015");
        assertThat(vulnerabilityConnector.isMoreRecent(v1, v2), is(true));
    }
}
