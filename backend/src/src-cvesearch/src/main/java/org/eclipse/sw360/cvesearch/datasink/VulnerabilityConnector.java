/*
 * Copyright (c) Bosch Software Innovations GmbH 2016.
 * Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.cvesearch.datasink;

import com.cloudant.client.api.CloudantClient;
import com.google.common.base.Strings;

import org.eclipse.sw360.datahandler.cloudantclient.DatabaseConnectorCloudant;
import org.eclipse.sw360.datahandler.common.DatabaseSettings;
import org.eclipse.sw360.datahandler.db.*;
import org.eclipse.sw360.datahandler.thrift.RequestStatus;
import org.eclipse.sw360.datahandler.thrift.components.Component;
import org.eclipse.sw360.datahandler.thrift.components.Release;
import org.eclipse.sw360.datahandler.thrift.cvesearch.UpdateType;
import org.eclipse.sw360.datahandler.thrift.cvesearch.VulnerabilityUpdateStatus;
import org.eclipse.sw360.datahandler.thrift.projects.Project;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.ReleaseVulnerabilityRelation;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import org.eclipse.sw360.vulnerabilities.common.VulnerabilityMapper;
import org.eclipse.sw360.vulnerabilities.db.VulnerabilityDatabaseHandler;
import org.ektorp.http.HttpClient;

import java.io.IOException;
import java.util.*;
import java.util.function.Supplier;

public class VulnerabilityConnector {

    VulnerabilityDatabaseHandler vulnerabilityDatabaseHandler;
    ProjectDatabaseHandler projectDatabaseHandler;
    ComponentRepository componentRepository;
    ReleaseRepository releaseRepository;
    ProjectRepository projectRepository;
    VendorRepository vendorRepository;

    public VulnerabilityConnector() throws IOException{
        DatabaseConnectorCloudant db = new DatabaseConnectorCloudant(DatabaseSettings.getConfiguredClient(), DatabaseSettings.COUCH_DB_DATABASE);

        vulnerabilityDatabaseHandler = new VulnerabilityDatabaseHandler();
        projectDatabaseHandler = new ProjectDatabaseHandler(DatabaseSettings.getConfiguredHttpClient(), DatabaseSettings.getConfiguredClient(), DatabaseSettings.COUCH_DB_DATABASE, DatabaseSettings.COUCH_DB_ATTACHMENTS);
        vendorRepository = new VendorRepository(db);
        releaseRepository = new ReleaseRepository(db, vendorRepository);
        componentRepository = new ComponentRepository(db, releaseRepository, vendorRepository);
        projectRepository = new ProjectRepository(db);
    }

    public VulnerabilityConnector(Supplier<CloudantClient> cclient, Supplier<HttpClient> hclient, String vmdbName, String dbName, String attchmntDbName) throws IOException {
        DatabaseConnectorCloudant db = new DatabaseConnectorCloudant(cclient, dbName);

        vulnerabilityDatabaseHandler = new VulnerabilityDatabaseHandler(hclient, vmdbName);
        projectDatabaseHandler = new ProjectDatabaseHandler(hclient, cclient, dbName, attchmntDbName);
        vendorRepository = new VendorRepository(db);
        releaseRepository = new ReleaseRepository(db, vendorRepository);
        componentRepository = new ComponentRepository(db, releaseRepository, vendorRepository);
        projectRepository = new ProjectRepository(db);
    }

    ///////////////////////////////////
    // get objects from database     //
    ///////////////////////////////////
    public Optional<Release> getRelease(String releaseId){
        return Optional.ofNullable(releaseRepository.get(releaseId))
                .map(r -> {
                    vendorRepository.fillVendor(r);
                    return r;
                });
    }

    public Optional<Component> getComponent(String componentId){
        return Optional.ofNullable(componentRepository.get(componentId));
    }

    public Optional<Project> getProject(String projectId){
        return Optional.ofNullable(projectRepository.get(projectId));
    }

    public List<Release> getAllReleases() {
        List<Release> allReleases = releaseRepository.getAll();
        allReleases.forEach(vendorRepository::fillVendor);
        return allReleases;
    }



    ///////////////////////////////////////
    // write vulnerabilities to database //
    ///////////////////////////////////////


    public boolean isMoreRecent(Vulnerability vulnerability, Vulnerability other) {
        //update if one of the dates is not set
        if (Strings.isNullOrEmpty(vulnerability.getLastExternalUpdate()) ||
                Strings.isNullOrEmpty(other.getLastExternalUpdate())) {
            return true;
        }

        return vulnerability.getLastExternalUpdate().compareTo(other.getLastExternalUpdate()) > 0;
    }

    public RequestStatus addOrUpdate(ReleaseVulnerabilityRelation partiallyFilledRelation) {
        ReleaseVulnerabilityRelation dbRelation = vulnerabilityDatabaseHandler.getRelationByIds(partiallyFilledRelation);
        if(dbRelation != null) {
            dbRelation = VulnerabilityMapper.updateFromReleaseVulnerabilityRelation(dbRelation, partiallyFilledRelation);
            return vulnerabilityDatabaseHandler.update(dbRelation);
        } else {
            return vulnerabilityDatabaseHandler.add(partiallyFilledRelation);
        }
    }

    public UpdateType addOrUpdate(Vulnerability vulnerability, ReleaseVulnerabilityRelation partiallyFilledRelation){
        RequestStatus vulRequestStatus = RequestStatus.SUCCESS;
        UpdateType updateType;
        Vulnerability dbVulnerability = vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, vulnerability.getExternalId());
        if(dbVulnerability != null) {
            if(isMoreRecent(vulnerability, dbVulnerability)) {
                updateType = UpdateType.UPDATED;
                dbVulnerability = VulnerabilityMapper.updateFromVulnerability(dbVulnerability, vulnerability);
                vulRequestStatus = vulnerabilityDatabaseHandler.update(dbVulnerability);
            } else {
                updateType = UpdateType.OLD;
            }
        } else {
            updateType = UpdateType.NEW;
            vulRequestStatus = vulnerabilityDatabaseHandler.add(vulnerability);
            dbVulnerability = vulnerability;
        }
        if(RequestStatus.FAILURE.equals(vulRequestStatus)){
            return UpdateType.FAILED;
        }
        partiallyFilledRelation.setVulnerabilityId(dbVulnerability.getId());
        RequestStatus requestStatus = addOrUpdate(partiallyFilledRelation);
        if(RequestStatus.FAILURE.equals(requestStatus)){
            return UpdateType.FAILED;
        }
        return updateType;
    }

    public VulnerabilityUpdateStatus addOrUpdate(Vulnerability vulnerability,
                                                 ReleaseVulnerabilityRelation partiallyFilledRelation,
                                                 VulnerabilityUpdateStatus currentVulnerabilityUpdateStatus){
        UpdateType updateType = addOrUpdate(vulnerability, partiallyFilledRelation);
        currentVulnerabilityUpdateStatus.getStatusToVulnerabilityIds()
                .get(updateType)
                .add(vulnerability.getExternalId());
        return currentVulnerabilityUpdateStatus;
    }

    public Map<UpdateType, List<Vulnerability>> addOrUpdateVulnerabilityAndSetId(
            Vulnerability vulnerability,
            Map<UpdateType, List<Vulnerability>> statusToVulnerabilities){

        Vulnerability dbVulnerability = vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, vulnerability.getExternalId());
        if(dbVulnerability != null){
            if(! isMoreRecent(vulnerability, dbVulnerability)) {
                statusToVulnerabilities.get(UpdateType.OLD).add(dbVulnerability);
                return statusToVulnerabilities;
            } else {
                dbVulnerability = VulnerabilityMapper.updateFromVulnerability(dbVulnerability, vulnerability);
                RequestStatus requestStatus = vulnerabilityDatabaseHandler.update(dbVulnerability);
                if (RequestStatus.SUCCESS.equals(requestStatus)){
                    statusToVulnerabilities.get(UpdateType.UPDATED).add(dbVulnerability);
                    return statusToVulnerabilities;
                }
             }
        } else {
            RequestStatus requestStatus = vulnerabilityDatabaseHandler.add(vulnerability);
            if (RequestStatus.SUCCESS.equals(requestStatus)){
                statusToVulnerabilities.get(UpdateType.NEW).add(vulnerability);
                return statusToVulnerabilities;
            }
        }
        statusToVulnerabilities.get(UpdateType.FAILED).add(vulnerability);
        return statusToVulnerabilities;
    }


    public Map<UpdateType, List<Vulnerability>> addOrUpdateVulnerabilitiesAndSetIds(List<Vulnerability> vulnerabilities) {
        Map<UpdateType, List<Vulnerability>> statusToVulnerabilities = new HashMap<>();
        for (UpdateType updateType: UpdateType.values()){
            statusToVulnerabilities.put(updateType, new ArrayList<>());
        }

        for (Vulnerability vulnerability : vulnerabilities) {
            statusToVulnerabilities = addOrUpdateVulnerabilityAndSetId(vulnerability, statusToVulnerabilities);
        }
        return statusToVulnerabilities;
    }

    public RequestStatus addReleaseVulnerabilityRelationsIfNecessary(String releaseId, List<String> vulnerabilityIds){
        return vulnerabilityDatabaseHandler.addRelationsIfNecessary(releaseId, vulnerabilityIds);
    }

    public RequestStatus addReleaseVulnerabilityRelationsIfNecessary(String releaseId, Map<String,List<String>> needleToVulnerabilityIds){
        return vulnerabilityDatabaseHandler.addRelationsIfNecessary(releaseId, needleToVulnerabilityIds);
    }
}
