/*
 * Copyright (c) Bosch Software Innovations GmbH 2016.
 * Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.cvesearch.datasink;

import com.ibm.cloud.cloudant.v1.Cloudant;
import org.eclipse.sw360.datahandler.spring.CouchDbContextInitializer;
import org.eclipse.sw360.datahandler.spring.DatabaseConfig;
import org.eclipse.sw360.datahandler.TestUtils;
import org.eclipse.sw360.datahandler.thrift.RequestStatus;
import org.eclipse.sw360.datahandler.thrift.cvesearch.UpdateType;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import org.eclipse.sw360.vulnerabilities.db.VulnerabilityDatabaseHandler;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.net.MalformedURLException;
import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;


@RunWith(SpringJUnit4ClassRunner.class)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
@ContextConfiguration(
        classes = {DatabaseConfig.class},
        initializers = {CouchDbContextInitializer.class}
)
@ActiveProfiles("test")
public class VulnerabilityConnectorTest {

    @Autowired
    private Cloudant client;

    @Autowired
    @Qualifier("COUCH_DB_ALL_NAMES")
    private Set<String> allDatabaseNames;

    Map<UpdateType, List<Vulnerability>> statusToVulnerabilityMap;

    @Mock
    VulnerabilityDatabaseHandler vulnerabilityDatabaseHandler;

    // Initialize the mocked objects
    @Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Autowired
    VulnerabilityConnector vulnerabilityConnector;

    @Before
    public void setUp() {
        vulnerabilityConnector.vulnerabilityDatabaseHandler = vulnerabilityDatabaseHandler;
        statusToVulnerabilityMap = new HashMap<>();
        for (UpdateType updateType: UpdateType.values()){
            statusToVulnerabilityMap.put(updateType, new ArrayList<>());
        }
    }

    @After
    public void tearDown() throws MalformedURLException {
        TestUtils.deleteAllDatabases(client, allDatabaseNames);
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdOldVulnerability() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv1").setExternalId("eid");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(v1);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertEquals("idv1", resultMap.get(UpdateType.OLD).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.NEW));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.UPDATED));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.FAILED));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdNewVulnerability() throws Exception {
        Vulnerability v1 = new Vulnerability().setId("idv1").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(null);
        when(vulnerabilityDatabaseHandler.add(v1)).thenReturn(RequestStatus.SUCCESS);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v1, statusToVulnerabilityMap);

        assertEquals("idv1", resultMap.get(UpdateType.NEW).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.OLD));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.UPDATED));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.FAILED));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdUpdateVulnerability() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv1").setExternalId("eid");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(v1);
        when(vulnerabilityDatabaseHandler.update(v1)).thenReturn(RequestStatus.SUCCESS);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertEquals("idv1", resultMap.get(UpdateType.UPDATED).get(0).getId());
        assertEquals("2000-01-01", resultMap.get(UpdateType.UPDATED).get(0).getLastExternalUpdate());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.NEW));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.OLD));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.FAILED));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdFailAdd() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv1").setExternalId("eid");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(v1);
        when(vulnerabilityDatabaseHandler.update(v1)).thenReturn(RequestStatus.FAILURE);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertEquals("idv2", resultMap.get(UpdateType.FAILED).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.NEW));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.OLD));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.UPDATED));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdFailUpdate() throws Exception {
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(null);
        when(vulnerabilityDatabaseHandler.add(v2)).thenReturn(RequestStatus.FAILURE);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertEquals("idv2", resultMap.get(UpdateType.FAILED).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.NEW));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.OLD));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.UPDATED));
    }

    @Test
    public void testaddOrUpdateVulnerabilitiesAndSetIds(){
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv1").setExternalId("eid1");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid2");
        Vulnerability v3= new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv3").setExternalId("eid1");
        Vulnerability v4 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv4").setExternalId("eid2");
        Vulnerability v5 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv5").setExternalId("eid5");

        List<Vulnerability> vulnerabilityList = Arrays.asList(v3,v4,v5);

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid1")).thenReturn(v1);
        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid2")).thenReturn(v2);
        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid5")).thenReturn(null);
        when(vulnerabilityDatabaseHandler.add(v5)).thenReturn(RequestStatus.SUCCESS);
        when(vulnerabilityDatabaseHandler.update(v1)).thenReturn(RequestStatus.SUCCESS);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilitiesAndSetIds(vulnerabilityList);

        assertEquals("idv1", resultMap.get(UpdateType.UPDATED).get(0).getId());
        assertEquals("idv5", resultMap.get(UpdateType.NEW).get(0).getId());
        assertEquals("idv2", resultMap.get(UpdateType.OLD).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.FAILED));
    }

    @Test
    public void testIsMoreRecentEmpty() throws Exception {
        Vulnerability v1 = new Vulnerability();
        Vulnerability v2 = new Vulnerability();
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentFirstNull() throws Exception {
        Vulnerability v1 = new Vulnerability();
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2016");
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentSecondNull() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2016");
        Vulnerability v2 = new Vulnerability();
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentFirstEmpty() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2016");
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentSecondEmpty() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2016");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("");
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentFirstOlder() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2015");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2016");
        assertFalse(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentSecondOlder() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2016");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2015");
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }
}
