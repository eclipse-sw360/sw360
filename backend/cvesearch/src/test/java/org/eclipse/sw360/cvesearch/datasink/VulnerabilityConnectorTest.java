/*
 * Copyright (c) Bosch Software Innovations GmbH 2016.
 * Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.cvesearch.datasink;

import org.eclipse.sw360.datahandler.common.DatabaseSettingsTest;
import org.eclipse.sw360.datahandler.thrift.RequestStatus;
import org.eclipse.sw360.datahandler.thrift.cvesearch.UpdateType;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import org.eclipse.sw360.vulnerabilities.db.VulnerabilityDatabaseHandler;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import com.ibm.cloud.sdk.core.service.exception.ConflictException;
import static org.junit.Assert.fail;

import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;


@RunWith(MockitoJUnitRunner.class)
public class VulnerabilityConnectorTest {
    Map<UpdateType, List<Vulnerability>> statusToVulnerabilityMap;

    @Mock
    VulnerabilityDatabaseHandler vulnerabilityDatabaseHandler;

    VulnerabilityConnector vulnerabilityConnector;

    @Before
    public void setUp() throws Exception {
        // Retry logic to handle database conflicts during initialization
        int maxRetries = 3;
        long retryDelayMs = 1000;
        
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                vulnerabilityConnector = new VulnerabilityConnector(
                    DatabaseSettingsTest.getConfiguredClient(), 
                    DatabaseSettingsTest.COUCH_DB_VM, 
                    DatabaseSettingsTest.COUCH_DB_DATABASE, 
                    DatabaseSettingsTest.COUCH_DB_ATTACHMENTS
                );
                break;
            } catch (ConflictException e) {
                if (attempt == maxRetries) {
                    fail("Failed to initialize VulnerabilityConnector after " + maxRetries + 
                         " attempts due to database conflict: " + e.getMessage());
                }
                System.out.println("Database conflict on attempt " + attempt + 
                                 ", retrying in " + retryDelayMs + "ms...");
                
                try {
                    Thread.sleep(retryDelayMs);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    fail("Setup interrupted: " + ie.getMessage());
                }
                retryDelayMs *= 2;
                
            } catch (Exception e) {
                fail("Setup failed with unexpected error: " + e.getMessage());
            }
        }
        vulnerabilityConnector.vulnerabilityDatabaseHandler = vulnerabilityDatabaseHandler;
        statusToVulnerabilityMap = new HashMap<>();
        for (UpdateType updateType: UpdateType.values()){
            statusToVulnerabilityMap.put(updateType, new ArrayList<>());
        }
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdOldVulnerability() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv1").setExternalId("eid");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(v1);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertEquals("idv1", resultMap.get(UpdateType.OLD).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.NEW));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.UPDATED));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.FAILED));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdNewVulnerability() throws Exception {
        Vulnerability v1 = new Vulnerability().setId("idv1").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(null);
        when(vulnerabilityDatabaseHandler.add(v1)).thenReturn(RequestStatus.SUCCESS);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v1, statusToVulnerabilityMap);

        assertEquals("idv1", resultMap.get(UpdateType.NEW).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.OLD));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.UPDATED));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.FAILED));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdUpdateVulnerability() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv1").setExternalId("eid");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(v1);
        when(vulnerabilityDatabaseHandler.update(v1)).thenReturn(RequestStatus.SUCCESS);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertEquals("idv1", resultMap.get(UpdateType.UPDATED).get(0).getId());
        assertEquals("2000-01-01", resultMap.get(UpdateType.UPDATED).get(0).getLastExternalUpdate());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.NEW));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.OLD));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.FAILED));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdFailAdd() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv1").setExternalId("eid");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(v1);
        when(vulnerabilityDatabaseHandler.update(v1)).thenReturn(RequestStatus.FAILURE);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertEquals("idv2", resultMap.get(UpdateType.FAILED).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.NEW));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.OLD));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.UPDATED));
    }

    @Test
    public void testAddOrUpdateVulnerabilityAndSetIdFailUpdate() throws Exception {
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid");

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid")).thenReturn(null);
        when(vulnerabilityDatabaseHandler.add(v2)).thenReturn(RequestStatus.FAILURE);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilityAndSetId(v2, statusToVulnerabilityMap);

        assertEquals("idv2", resultMap.get(UpdateType.FAILED).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.NEW));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.OLD));
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.UPDATED));
    }

    @Test
    public void testaddOrUpdateVulnerabilitiesAndSetIds(){
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv1").setExternalId("eid1");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv2").setExternalId("eid2");
        Vulnerability v3= new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv3").setExternalId("eid1");
        Vulnerability v4 = new Vulnerability().setLastExternalUpdate("2000-01-01").setId("idv4").setExternalId("eid2");
        Vulnerability v5 = new Vulnerability().setLastExternalUpdate("1999-12-31").setId("idv5").setExternalId("eid5");

        List<Vulnerability> vulnerabilityList = Arrays.asList(v3,v4,v5);

        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid1")).thenReturn(v1);
        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid2")).thenReturn(v2);
        when(vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, "eid5")).thenReturn(null);
        when(vulnerabilityDatabaseHandler.add(v5)).thenReturn(RequestStatus.SUCCESS);
        when(vulnerabilityDatabaseHandler.update(v1)).thenReturn(RequestStatus.SUCCESS);

        Map<UpdateType, List<Vulnerability>> resultMap = vulnerabilityConnector.addOrUpdateVulnerabilitiesAndSetIds(vulnerabilityList);

        assertEquals("idv1", resultMap.get(UpdateType.UPDATED).get(0).getId());
        assertEquals("idv5", resultMap.get(UpdateType.NEW).get(0).getId());
        assertEquals("idv2", resultMap.get(UpdateType.OLD).get(0).getId());
        assertEquals(Collections.EMPTY_LIST, resultMap.get(UpdateType.FAILED));
    }

    @Test
    public void testIsMoreRecentEmpty() throws Exception {
        Vulnerability v1 = new Vulnerability();
        Vulnerability v2 = new Vulnerability();
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentFirstNull() throws Exception {
        Vulnerability v1 = new Vulnerability();
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2016");
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentSecondNull() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2016");
        Vulnerability v2 = new Vulnerability();
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentFirstEmpty() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2016");
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentSecondEmpty() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2016");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("");
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentFirstOlder() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2015");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2016");
        assertFalse(vulnerabilityConnector.isMoreRecent(v1, v2));
    }

    @Test
    public void testIsMoreRecentSecondOlder() throws Exception {
        Vulnerability v1 = new Vulnerability().setLastExternalUpdate("2016");
        Vulnerability v2 = new Vulnerability().setLastExternalUpdate("2015");
        assertTrue(vulnerabilityConnector.isMoreRecent(v1, v2));
    }
}
