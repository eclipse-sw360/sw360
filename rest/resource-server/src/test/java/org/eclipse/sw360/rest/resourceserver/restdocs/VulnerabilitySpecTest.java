/*
 * Copyright Siemens AG, 2018. Part of the SW360 Portal Project.
 *
  * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */

package org.eclipse.sw360.rest.resourceserver.restdocs;

import org.apache.thrift.TException;
import org.eclipse.sw360.datahandler.thrift.VerificationState;
import org.eclipse.sw360.datahandler.thrift.VerificationStateInfo;
import org.eclipse.sw360.datahandler.thrift.components.ComponentType;
import org.eclipse.sw360.datahandler.thrift.components.Release;
import org.eclipse.sw360.datahandler.thrift.components.ReleaseClearingStatusData;
import org.eclipse.sw360.datahandler.thrift.projects.Project;
import org.eclipse.sw360.datahandler.thrift.projects.ProjectType;
import org.eclipse.sw360.datahandler.thrift.users.User;
import org.eclipse.sw360.datahandler.thrift.users.UserGroup;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.*;
import org.eclipse.sw360.rest.resourceserver.TestHelper;
import org.eclipse.sw360.rest.resourceserver.core.JacksonCustomizations;
import org.eclipse.sw360.rest.resourceserver.core.JacksonCustomizations.Sw360Module.CVEReferenceMixin;
import org.eclipse.sw360.rest.resourceserver.core.JacksonCustomizations.Sw360Module.VendorAdvisoryMixin;
import org.eclipse.sw360.rest.resourceserver.core.JacksonCustomizations.Sw360Module.VulnerabilityMixinForCreateUpdate;
import org.eclipse.sw360.rest.resourceserver.core.JacksonCustomizations.Sw360Module.VulnerabilityApiDTOMixin;
import org.eclipse.sw360.rest.resourceserver.release.Sw360ReleaseService;
import org.eclipse.sw360.rest.resourceserver.user.Sw360UserService;
import org.eclipse.sw360.rest.resourceserver.vulnerability.Sw360VulnerabilityService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.data.rest.webmvc.ResourceNotFoundException;
import org.springframework.hateoas.MediaTypes;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.springframework.restdocs.hypermedia.HypermediaDocumentation.linkWithRel;
import static org.springframework.restdocs.hypermedia.HypermediaDocumentation.links;
import static org.springframework.restdocs.payload.PayloadDocumentation.fieldWithPath;
import static org.springframework.restdocs.payload.PayloadDocumentation.subsectionWithPath;
import static org.springframework.restdocs.request.RequestDocumentation.parameterWithName;
import static org.springframework.restdocs.request.RequestDocumentation.formParameters;
import static org.springframework.restdocs.payload.PayloadDocumentation.requestFields;
import static org.springframework.restdocs.payload.PayloadDocumentation.responseFields;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringJUnit4ClassRunner.class)
public class VulnerabilitySpecTest extends TestRestDocsSpecBase {

    @Value("${sw360.test-user-id}")
    private String testUserId;

    @Value("${sw360.test-user-password}")
    private String testUserPassword;

    @MockBean
    private Sw360VulnerabilityService vulnerabilityServiceMock;

    @MockBean
    private Sw360ReleaseService releaseServiceMock;

    @MockBean
    private Sw360UserService userServiceMock;

    private Vulnerability vulnerability, vulnerability3, vulnerability4, vulnerability5;

    private VulnerabilityApiDTO vulnerabilityDTO, vulnerabilityDTO3, vulnerabilityDTO4, vulnerabilityDTO5, vulnerabilityDTO2;
    private ObjectMapper mapper;

    private ReleaseVulnerabilityRelation releaseVulnerabilityRelation;

    private Project project;

    @Before
    public void before() throws TException {
        vulnerability = new Vulnerability();
        vulnerability.setId("12345");
        vulnerability.setAction("new");
        vulnerability.setCwe("common weakness enumeration");
        vulnerability.setDescription("Description of vulnerability");
        vulnerability.setExternalId("123");
        vulnerability.setPriority("high");
        vulnerability.setTitle("Title of vulnerability 12345");
        vulnerability.setRevision("1");
        vulnerability.setCvss(3);
        vulnerability.setReferences(new HashSet<>(Arrays.asList("reference-1", "reference-2")));
        vulnerability.setPublishDate("01-01-2018");
        vulnerability.setLastExternalUpdate("last-update-id-123");

        vulnerabilityDTO = new VulnerabilityApiDTO();
        vulnerabilityDTO.setId("12345");
        vulnerabilityDTO.setAction("new");
        vulnerabilityDTO.setCwe("common weakness enumeration");
        vulnerabilityDTO.setDescription("Description of vulnerability");
        vulnerabilityDTO.setExternalId("123");
        vulnerabilityDTO.setPriority("high");
        vulnerabilityDTO.setTitle("Title of vulnerability 12345");
        vulnerabilityDTO.setRevision("1");
        vulnerabilityDTO.setCvss("3");
        vulnerabilityDTO.setReferences(new HashSet<>(Arrays.asList("reference-1", "reference-2")));
        vulnerabilityDTO.setPublishDate("01-01-2018");
        vulnerabilityDTO.setLastExternalUpdate("last-update-id-123");

        Vulnerability vulnerability2 = new Vulnerability();
        vulnerability2.setId("7854");
        vulnerability2.setAction("remove");
        vulnerability2.setCwe("common weakness enumeration");
        vulnerability2.setDescription("Description of vulnerability");
        vulnerability2.setExternalId("7543");
        vulnerability2.setPriority("low");
        vulnerability2.setTitle("Title of vulnerability 7854");
        vulnerability2.setRevision("2");
        vulnerability2.setCvss(4);

        mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.addMixIn(Vulnerability.class, VulnerabilityMixinForCreateUpdate.class);
        mapper.addMixIn(CVEReference.class, CVEReferenceMixin.class);
        mapper.addMixIn(VendorAdvisory.class, VendorAdvisoryMixin.class);
        mapper.addMixIn(VulnerabilityApiDTO.class, VulnerabilityApiDTOMixin.class);

        Map<String, String> mapForImpactAccess = new HashMap<>();
        mapForImpactAccess.put("Key 1", "Value 1");
        mapForImpactAccess.put("Key 2", "Value 2");

        CVEReference cr1 = new CVEReference().setNumber("1234").setYear("1992");
        CVEReference cr2 = new CVEReference().setNumber("4321").setYear("2021");
        Set<CVEReference> cveReferenceSet = new HashSet<>();
        cveReferenceSet.add(cr1);
        cveReferenceSet.add(cr2);

        Set<String> cveReferences = new HashSet<>();
        cveReferences.add("1234-1992");
        cveReferences.add("1234-1992");

        Set<VendorAdvisory> vendorAdvisorySet = new HashSet<>();
        VendorAdvisory va1 = new VendorAdvisory("vendor1", "name1", "http://url1");
        VendorAdvisory va2 = new VendorAdvisory("vendor2", "name2", "http://url2");
        vendorAdvisorySet.add(va1);
        vendorAdvisorySet.add(va2);

        Map<String, Map<String, String>> mapForCVEMetaData = new HashMap<>();
        mapForCVEMetaData.put("Cve meta data", mapForImpactAccess);

        vulnerability3 = vulnerability.deepCopy();
        vulnerability3.setAssignedExtComponentIds(new HashSet<>(Arrays.asList("comp-id-1", "comp-id-2")));
        vulnerability3.setCveReferences(cveReferenceSet);
        vulnerability3.setCveFurtherMetaDataPerSource(mapForCVEMetaData);
        vulnerability3.setImpact(mapForImpactAccess);
        vulnerability3.setAccess(mapForImpactAccess);
        vulnerability3.setCvssTime("2019-01-01");
        vulnerability3.setPriorityText("Priority Text");
        vulnerability3.setLegalNotice("Legal Notice");
        vulnerability3.setVendorAdvisories(vendorAdvisorySet);
        vulnerability3.setExtendedDescription("Extended Description");
        vulnerability3.setVulnerableConfiguration(mapForImpactAccess);
        vulnerability3.setExternalId("987");

        vulnerabilityDTO3 = vulnerabilityDTO.deepCopy();
        vulnerabilityDTO3.setAssignedExtComponentIds(new HashSet<>(Arrays.asList("comp-id-1", "comp-id-2")));
        vulnerabilityDTO3.setCveReferences(cveReferences);
        vulnerabilityDTO3.setCveFurtherMetaDataPerSource(mapForCVEMetaData);
        vulnerabilityDTO3.setImpact(mapForImpactAccess);
        vulnerabilityDTO3.setAccess(mapForImpactAccess);
        vulnerabilityDTO3.setCvssTime("2019-01-01");
        vulnerabilityDTO3.setPriorityText("Priority Text");
        vulnerabilityDTO3.setLegalNotice("Legal Notice");
        vulnerabilityDTO3.setVendorAdvisories(vendorAdvisorySet);
        vulnerabilityDTO3.setExtendedDescription("Extended Description");
        vulnerabilityDTO3.setVulnerableConfiguration(mapForImpactAccess);
        vulnerabilityDTO3.setExternalId("987");


        List<Vulnerability> vulnerabilityList = new ArrayList<>();
        vulnerabilityList.add(vulnerability);
        vulnerabilityList.add(vulnerability2);

        vulnerability4 = vulnerability3.deepCopy();
        vulnerability5 = vulnerability3.deepCopy();

        vulnerabilityDTO4 = vulnerabilityDTO3.deepCopy();
        vulnerabilityDTO5 = vulnerabilityDTO3.deepCopy();

        vulnerability4.setExternalId("9876567890");
        vulnerability4.setTitle("Updated Title");
        vulnerability4.setExternalId("98765");

        vulnerabilityDTO4.setExternalId("9876567890");
        vulnerabilityDTO4.setTitle("Updated Title");
        vulnerabilityDTO4.setExternalId("98765");

        project = new Project();
        project.setId("376576");
        project.setName("Emerald Web");
        project.setProjectType(ProjectType.PRODUCT);
        project.setVersion("1.0.2");
        project.setDescription("Emerald Web provides a suite of components for Critical Infrastructures.");
        project.setDomain("Hardware");
        project.setCreatedOn("2016-12-15");
        project.setCreatedBy("admin@sw360.org");
        project.setModerators(new HashSet<>(Arrays.asList("admin@sw360.org", "jane@sw360.org")));
        project.setBusinessUnit("sw360 AR");
        project.setExternalIds(Collections.singletonMap("mainline-id-project", "515432"));
        project.setOwnerAccountingUnit("4822");
        project.setOwnerCountry("DE");

        List<ReleaseVulnerabilityRelation> releaseRelation = new ArrayList<ReleaseVulnerabilityRelation>();
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = new VulnerabilityWithReleaseRelations(
                vulnerability, releaseRelation);

        Release release = new Release("Test Release", "1", "12345").setId("1234");
        VerificationStateInfo vsi = new VerificationStateInfo("2021-06-17", "admin@sw360.org",
                VerificationState.CHECKED).setComment("Comment statement");
        List<VerificationStateInfo> vsiList = new ArrayList<VerificationStateInfo>();
        vsiList.add(vsi);
        releaseVulnerabilityRelation = new ReleaseVulnerabilityRelation("1234", null).setMatchedBy("matchedBy")
                .setUsedNeedle("usedNeedle").setVerificationStateInfo(vsiList);

        List<ReleaseVulnerabilityRelation> releaseVulnerabilityRelationList = new ArrayList<ReleaseVulnerabilityRelation>();
        releaseVulnerabilityRelationList.add(releaseVulnerabilityRelation);
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations2 = new VulnerabilityWithReleaseRelations(
                vulnerability4, releaseVulnerabilityRelationList);

        User user = new User();
        user.setId("123456789");
        user.setEmail("admin@sw360.org");
        user.setFullname("John Doe");
        user.setUserGroup(UserGroup.ADMIN);

        ReleaseClearingStatusData releaseClearingStatusData = new ReleaseClearingStatusData();
        releaseClearingStatusData.setComponentType(ComponentType.INTERNAL);
        releaseClearingStatusData.setProjectNames("Demo Project");
        Map<String, String> releaseExternalIds = new HashMap<>();
        releaseExternalIds.put("svmComponentId", "svmComponentId12358");
        Map<String, String> releaseAdditionalData = new HashMap<>();
        releaseExternalIds.put("svmShortStatus", "Not Applicable");
        Release releaseObj = new Release();
        releaseObj.setAdditionalData(releaseAdditionalData);
        releaseObj.setExternalIds(releaseExternalIds);
        releaseObj.setId("564785");
        releaseObj.setName("VulnbilityTrackStatusReleaseObj");
        releaseClearingStatusData.setRelease(releaseObj);

        List<ReleaseClearingStatusData> releaseClearingStatusList = new ArrayList<>();
        releaseClearingStatusList.add(releaseClearingStatusData);

        given(this.userServiceMock.getUserByEmailOrExternalId("admin@sw360.org")).willReturn(user);
        given(this.releaseServiceMock.getReleaseForUserById(any(), any())).willReturn(release);
        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq(vulnerability4.getExternalId()), any())).willReturn(vulnerabilityWithReleaseRelations2);
        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq(vulnerability5.getExternalId()), any())).willReturn(vulnerabilityWithReleaseRelations);
        given(this.vulnerabilityServiceMock.getVulnerabilities(any())).willReturn(vulnerabilityList);
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq(vulnerability.getExternalId()), any())).willReturn(vulnerability);
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq(vulnerability4.getExternalId()), any())).willReturn(vulnerability4);
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq(vulnerability5.getExternalId()), any())).willReturn(vulnerability5);
        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq(vulnerability.getExternalId()), any())).willReturn(vulnerabilityWithReleaseRelations);
        given(this.vulnerabilityServiceMock.getObjectMapper()).willReturn(mapper);
        Mockito.doNothing().when(vulnerabilityServiceMock).createUpdateDeleteVulnerability(any(), any(), any());
        Mockito.doNothing().when(vulnerabilityServiceMock).createUpdateDeleteVulnerabilityReleaseRelation(any(), any(), any());
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq(vulnerability3.getExternalId()), any())).willThrow(new ResourceNotFoundException("Vulnerability Not found"));
        given(this.vulnerabilityServiceMock.getReleasesClearingStatusWithAccessibility(any(),any())).willReturn(releaseClearingStatusList);
    }

    @Test
    public void should_document_get_vulnerabilities() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(get("/api/vulnerabilities")
                .header("Authorization", "Bearer " + accessToken)
                .param("page", "0")
                .param("page_entries", "5")
                .param("sort", "priority,desc")
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isOk())
                .andDo(this.documentationHandler.document(
                        formParameters(
                                parameterWithName("page").description("Page of vulnerabilities"),
                                parameterWithName("page_entries").description("Amount of vulnerabilities per page"),
                                parameterWithName("sort").description("Defines order of the vulnerabilities")
                        ),
                        links(
                                linkWithRel("curies").description("Curies are used for online documentation"),
                                linkWithRel("first").description("Link to first page"),
                                linkWithRel("last").description("Link to last page")
                        ),
                        responseFields(
                                subsectionWithPath("_embedded.sw360:vulnerabilityApiDTOes.[]title").description("The title of the vulnerability"),
                                subsectionWithPath("_embedded.sw360:vulnerabilityApiDTOes.[]externalId").description("The external Id of the vulnerability"),
                                subsectionWithPath("_embedded.sw360:vulnerabilityApiDTOes").description("An array of <<resources-vulnerabilities, Vulnerabilities resources>>"),
                                subsectionWithPath("_links").description("<<resources-index-links,Links>> to other resources"),
                                fieldWithPath("page").description("Additional paging information"),
                                fieldWithPath("page.size").description("Number of vulnerabilities per page"),
                                fieldWithPath("page.totalElements").description("Total number of all existing vulnerabilities"),
                                fieldWithPath("page.totalPages").description("Total number of pages"),
                                fieldWithPath("page.number").description("Number of the current page")
                        )));
    }

    @Test
    public void should_document_get_vulnerability() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(get("/api/vulnerabilities/" + vulnerabilityDTO.getExternalId())
                .header("Authorization", "Bearer " + accessToken)
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isOk())
                .andDo(this.documentationHandler.document(
                        links(
                                linkWithRel("self").description("The <<resources-vulnerabilities, Vulnerabilities resource>>")
                        ),
                        responseFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                fieldWithPath("publishDate").description("The publish date of the vulnerability"),
                                fieldWithPath("lastExternalUpdate").description("The last external update of the vulnerability"),
                                fieldWithPath("priority").description("The priority of vulnerability"),
                                fieldWithPath("action").description("The action needs to be taken to resolve vulnerability"),
                                fieldWithPath("references").description("The references for the vulnerability"),
                                fieldWithPath("cvss").description("The cvss value of the vulnerability"),
                                fieldWithPath("isSetCvss").description("The cvss value of the vulnerability"),
                                subsectionWithPath("_links").description("<<resources-index-links,Links>> to other resources")
                        )));
    }

    @Test
    public void should_document_create_vulnerability() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(post("/api/vulnerabilities")
                .header("Authorization", "Bearer " + accessToken)
                .contentType(MediaTypes.HAL_JSON)
                .content(mapper.writeValueAsString(vulnerabilityDTO3))
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isCreated())
                .andDo(this.documentationHandler.document(
                        requestFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                fieldWithPath("publishDate").description("The publish date of the vulnerability"),
                                fieldWithPath("lastExternalUpdate").description("The last external update of the vulnerability"),
                                fieldWithPath("priority").description("The priority of vulnerability"),
                                fieldWithPath("priorityText").description("The priority text of vulnerability"),
                                subsectionWithPath("access").description("The access value of the vulnerability"),
                                subsectionWithPath("impact").description("The impact of the vulnerability"),
                                fieldWithPath("action").description("The action needs to be taken to resolve vulnerability"),
                                fieldWithPath("legalNotice").description("The legal notice of the vulnerability"),
                                fieldWithPath("assignedExtComponentIds").description("The assignedExtComponentIds for the vulnerability"),
                                fieldWithPath("extendedDescription").description("The extended description of the vulnerability"),
                                fieldWithPath("cvss").description("The cvss value of the vulnerability"),
                                fieldWithPath("cvssTime").description("The cvss time of the vulnerability"),
                                fieldWithPath("cveReferences").description("The cve references for the vulnerability"),
                                fieldWithPath("vendorAdvisories").description("The vendor advisories for the vulnerability"),
                                fieldWithPath("vendorAdvisories[]vendor").description("The vendor of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]name").description("The name of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]url").description("The url of vendor advisories"),
                                fieldWithPath("references").description("The references for the vulnerability"),
                                subsectionWithPath("vulnerableConfiguration").description("The vulnerable configuration of the vulnerability"),
                                subsectionWithPath("cveFurtherMetaDataPerSource").description("The cve further metadata per source of the vulnerability")
                        ),
                        responseFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                fieldWithPath("publishDate").description("The publish date of the vulnerability"),
                                fieldWithPath("lastExternalUpdate").description("The last external update of the vulnerability"),
                                fieldWithPath("priority").description("The priority of vulnerability"),
                                fieldWithPath("priorityText").description("The priority text of vulnerability"),
                                subsectionWithPath("access").description("The access value of the vulnerability"),
                                subsectionWithPath("impact").description("The impact of the vulnerability"),
                                fieldWithPath("action").description("The action needs to be taken to resolve vulnerability"),
                                fieldWithPath("legalNotice").description("The legal notice of the vulnerability"),
                                fieldWithPath("assignedExtComponentIds").description("The assignedExtComponentIds for the vulnerability"),
                                fieldWithPath("extendedDescription").description("The extended description of the vulnerability"),
                                fieldWithPath("cvss").description("The cvss value of the vulnerability"),
                                fieldWithPath("cvssTime").description("The cvss time of the vulnerability"),
                                fieldWithPath("cveReferences").description("The cve references for the vulnerability"),
                                fieldWithPath("vendorAdvisories").description("The vendor advisories for the vulnerability"),
                                fieldWithPath("vendorAdvisories[]vendor").description("The vendor of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]name").description("The name of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]url").description("The url of vendor advisories"),
                                fieldWithPath("references").description("The references for the vulnerability"),
                                subsectionWithPath("vulnerableConfiguration").description("The vulnerable configuration of the vulnerability"),
                                subsectionWithPath("cveFurtherMetaDataPerSource").description("The cve further metadata per source of the vulnerability")
                        )));
    }

    @Test
    public void should_document_update_vulnerability() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(patch("/api/vulnerabilities/" + vulnerabilityDTO4.getExternalId())
                .header("Authorization", "Bearer " + accessToken)
                .contentType(MediaTypes.HAL_JSON)
                .content(mapper.writeValueAsString(vulnerabilityDTO4))
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isCreated())
                .andDo(this.documentationHandler.document(
                        requestFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                fieldWithPath("publishDate").description("The publish date of the vulnerability"),
                                fieldWithPath("lastExternalUpdate").description("The last external update of the vulnerability"),
                                fieldWithPath("priority").description("The priority of vulnerability"),
                                fieldWithPath("priorityText").description("The priority text of vulnerability"),
                                subsectionWithPath("access").description("The access value of the vulnerability"),
                                subsectionWithPath("impact").description("The impact of the vulnerability"),
                                fieldWithPath("action").description("The action needs to be taken to resolve vulnerability"),
                                fieldWithPath("legalNotice").description("The legal notice of the vulnerability"),
                                fieldWithPath("assignedExtComponentIds").description("The assignedExtComponentIds for the vulnerability"),
                                fieldWithPath("extendedDescription").description("The extended description of the vulnerability"),
                                fieldWithPath("cvss").description("The cvss value of the vulnerability"),
                                fieldWithPath("cvssTime").description("The cvss time of the vulnerability"),
                                fieldWithPath("cveReferences").description("The cve references for the vulnerability"),
                                fieldWithPath("vendorAdvisories").description("The vendor advisories for the vulnerability"),
                                fieldWithPath("vendorAdvisories[]vendor").description("The vendor of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]name").description("The name of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]url").description("The url of vendor advisories"),
                                fieldWithPath("references").description("The references for the vulnerability"),
                                subsectionWithPath("vulnerableConfiguration").description("The vulnerable configuration of the vulnerability"),
                                subsectionWithPath("cveFurtherMetaDataPerSource").description("The cve further metadata per source of the vulnerability")
                        ),
                        responseFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                fieldWithPath("publishDate").description("The publish date of the vulnerability"),
                                fieldWithPath("lastExternalUpdate").description("The last external update of the vulnerability"),
                                fieldWithPath("priority").description("The priority of vulnerability"),
                                fieldWithPath("priorityText").description("The priority text of vulnerability"),
                                subsectionWithPath("access").description("The access value of the vulnerability"),
                                subsectionWithPath("impact").description("The impact of the vulnerability"),
                                fieldWithPath("action").description("The action needs to be taken to resolve vulnerability"),
                                fieldWithPath("legalNotice").description("The legal notice of the vulnerability"),
                                fieldWithPath("assignedExtComponentIds").description("The assignedExtComponentIds for the vulnerability"),
                                fieldWithPath("extendedDescription").description("The extended description of the vulnerability"),
                                fieldWithPath("cvss").description("The cvss value of the vulnerability"),
                                fieldWithPath("cvssTime").description("The cvss time of the vulnerability"),
                                fieldWithPath("cveReferences").description("The cve references for the vulnerability"),
                                fieldWithPath("vendorAdvisories").description("The vendor advisories for the vulnerability"),
                                fieldWithPath("vendorAdvisories[]vendor").description("The vendor of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]name").description("The name of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]url").description("The url of vendor advisories"),
                                fieldWithPath("references").description("The references for the vulnerability"),
                                subsectionWithPath("vulnerableConfiguration").description("The vulnerable configuration of the vulnerability"),
                                subsectionWithPath("cveFurtherMetaDataPerSource").description("The cve further metadata per source of the vulnerability")
                        )));
    }

    @Test
    public void should_document_delete_vulnerability() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(delete("/api/vulnerabilities/" + vulnerabilityDTO.getExternalId())
                .header("Authorization", "Bearer " + accessToken)
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isMultiStatus())
                .andDo(this.documentationHandler.document(
                        responseFields(
                                fieldWithPath("[].resourceId").description("id of the deleted resource"),
                                fieldWithPath("[].status").description("status of the delete operation")
                        )
                ));
    }

    @Test
    public void should_document_delete_release_vulnerability_relation() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(delete("/api/vulnerabilities/" + vulnerability4.getExternalId() + "/release/1234")
                .header("Authorization", "Bearer " + accessToken)
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isMultiStatus())
                .andDo(this.documentationHandler.document(
                        responseFields(
                                fieldWithPath("[].resourceId").description("id of the deleted resources"),
                                fieldWithPath("[].status").description("status of the delete operation")
                        )
                ));
    }

    @Test
    public void should_document_create_release_vulnerability_relation() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(post("/api/vulnerabilities/" + vulnerabilityDTO5.getExternalId() + "/releaseVulnerabilityRelation")
                .header("Authorization", "Bearer " + accessToken)
                .contentType(MediaTypes.HAL_JSON)
                .content(this.objectMapper.writeValueAsString(releaseVulnerabilityRelation))
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isOk())
                .andDo(this.documentationHandler.document(
                        requestFields(
                                fieldWithPath("releaseId").description("The id of the release"),
                                fieldWithPath("verificationStateInfo").description("The verification state info"),
                                fieldWithPath("verificationStateInfo[]checkedOn").description("The verification state checked on"),
                                fieldWithPath("verificationStateInfo[]checkedBy").description("The verification state checked by"),
                                fieldWithPath("verificationStateInfo[]comment").description("The verification state comment"),
                                fieldWithPath("verificationStateInfo[]verificationState").description("The verification state. Possible Value - " + Arrays.asList(VerificationState.values())),
                                fieldWithPath("matchedBy").description("The matched by value"),
                                fieldWithPath("usedNeedle").description("The used needle")
                        ),
                        responseFields(
                                fieldWithPath("releaseId").description("The id of the release"),
                                fieldWithPath("vulnerabilityId").description("The id of the vulnerability"),
                                fieldWithPath("verificationStateInfo").description("The verification state info"),
                                fieldWithPath("verificationStateInfo[]checkedOn").description("The verification state checked on"),
                                fieldWithPath("verificationStateInfo[]checkedBy").description("The verification state checked by"),
                                fieldWithPath("verificationStateInfo[]comment").description("The verification state comment"),
                                fieldWithPath("verificationStateInfo[]verificationState").description("The verification state. Possible Value - " + Arrays.asList(VerificationState.values())),
                                fieldWithPath("matchedBy").description("The matched by value"),
                                fieldWithPath("usedNeedle").description("The used needle")
                        )));
    }
    @Test
    public void should_document_get_vulnerabilities_tracking_status() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(get("/api/vulnerabilities/trackingStatus/" + project.getId())
                .param("page", "0")
                .param("page_entries", "5")
                .param("sortBy", "name")
                .param("sortOrder", "desc")
                .header("Authorization", "Bearer " + accessToken)
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isOk())
                .andDo(this.documentationHandler.document(
                        formParameters(
                                parameterWithName("page").description("Page number"),
                                parameterWithName("page_entries").description("Amount of items per page"),
                                parameterWithName("sortBy").description("Based on sortBy param sorting should happens"),
                                parameterWithName("sortOrder").description("sortOrder would be asc/desc")
                        ),
                        responseFields(
                                fieldWithPath("vulnerabilityTrackingStatus[].name").description("The name of the release"),
                                fieldWithPath("vulnerabilityTrackingStatus[].projectOrigin").description("The project origin"),
                                fieldWithPath("vulnerabilityTrackingStatus[].releaseId").description("The id of the release"),
                                fieldWithPath("vulnerabilityTrackingStatus[].shortStatus").description("The short status"),
                                fieldWithPath("vulnerabilityTrackingStatus[].svmTrackingStatus").description("The SVM tracking status"),
                                fieldWithPath("vulnerabilityTrackingStatus[].type").description("The component type"),
                                fieldWithPath("page").description("Additional paging information"),
                                fieldWithPath("page.size").description("Number of items per page"),
                                fieldWithPath("page.totalElements").description("Total number of items"),
                                fieldWithPath("page.totalPages").description("Total number of pages"),
                                fieldWithPath("page.number").description("Number of the current page")
                        )));
    }
}
