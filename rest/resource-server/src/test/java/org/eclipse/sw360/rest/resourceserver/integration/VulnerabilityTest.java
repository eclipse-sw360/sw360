/*
* Copyright Rohit Borra, 2025. Part of the SW360 GSOC Project.
*
* This program and the accompanying materials are made
* available under the terms of the Eclipse Public License 2.0
* which is available at https://www.eclipse.org/legal/epl-2.0/
*
* SPDX-License-Identifier: EPL-2.0
*/

package org.eclipse.sw360.rest.resourceserver.integration;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.thrift.TException;
import org.eclipse.sw360.datahandler.thrift.PaginationData;
import org.eclipse.sw360.datahandler.thrift.VerificationState;
import org.eclipse.sw360.datahandler.thrift.VerificationStateInfo;
import org.eclipse.sw360.datahandler.thrift.components.Release;
import org.eclipse.sw360.datahandler.thrift.components.ReleaseClearingStatusData;
import org.eclipse.sw360.datahandler.thrift.users.User;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.*;
import org.eclipse.sw360.rest.resourceserver.TestHelper;
import org.eclipse.sw360.rest.resourceserver.release.Sw360ReleaseService;
import org.eclipse.sw360.rest.resourceserver.vulnerability.Sw360VulnerabilityService;
import org.jetbrains.annotations.NotNull;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.context.junit4.SpringRunner;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;

import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.access.AccessDeniedException;
import org.eclipse.sw360.rest.resourceserver.core.BadRequestClientException;
import org.eclipse.sw360.rest.resourceserver.vulnerability.Sw360VulnerabilityService.VulnerabilityOperation;

@RunWith(SpringRunner.class)
public class VulnerabilityTest extends TestIntegrationBase {

    @Value("${local.server.port}")
    private int port;

    @MockitoBean
    private Sw360VulnerabilityService vulnerabilityServiceMock;

    @MockitoBean
    private Sw360ReleaseService releaseServiceMock;

    private Vulnerability testVulnerability;
    private VulnerabilityApiDTO testVulnerabilityDTO;
    private ReleaseVulnerabilityRelation testReleaseVulnerabilityRelation;
    private ObjectMapper objectMapper;

    @Before
    public void before() throws TException {
        // Setup test vulnerability
        testVulnerability = new Vulnerability();
        testVulnerability.setId("12345");
        testVulnerability.setExternalId("CVE-2023-1234");
        testVulnerability.setTitle("Test Vulnerability");
        testVulnerability.setDescription("Test vulnerability description");
        testVulnerability.setCwe("CWE-79");
        testVulnerability.setPriority("high");
        testVulnerability.setAction("new");
        testVulnerability.setCvss(7.5);
        testVulnerability.setPublishDate("2023-01-01");
        testVulnerability.setLastExternalUpdate("2023-01-02");
        testVulnerability.setReferences(new HashSet<>(Arrays.asList("ref1", "ref2")));

        // Setup test vulnerability DTO
        testVulnerabilityDTO = new VulnerabilityApiDTO();
        testVulnerabilityDTO.setId("12345");
        testVulnerabilityDTO.setExternalId("CVE-2023-1234");
        testVulnerabilityDTO.setTitle("Test Vulnerability");
        testVulnerabilityDTO.setDescription("Test vulnerability description");
        testVulnerabilityDTO.setCwe("CWE-79");
        testVulnerabilityDTO.setPriority("high");
        testVulnerabilityDTO.setAction("new");
        testVulnerabilityDTO.setCvss("7.5");
        testVulnerabilityDTO.setPublishDate("2023-01-01");
        testVulnerabilityDTO.setLastExternalUpdate("2023-01-02");
        testVulnerabilityDTO.setReferences(new HashSet<>(Arrays.asList("ref1", "ref2")));

        // Setup test release vulnerability relation
        testReleaseVulnerabilityRelation = new ReleaseVulnerabilityRelation();
        testReleaseVulnerabilityRelation.setReleaseId("release123");
        testReleaseVulnerabilityRelation.setVulnerabilityId("12345");
        testReleaseVulnerabilityRelation.setMatchedBy("manual");
        testReleaseVulnerabilityRelation.setUsedNeedle("CVE-2023-1234");

        VerificationStateInfo verificationStateInfo = new VerificationStateInfo();
        verificationStateInfo.setCheckedBy("admin@sw360.org");
        verificationStateInfo.setCheckedOn("2023-01-01");
        verificationStateInfo.setComment("Test verification");
        verificationStateInfo.setVerificationState(VerificationState.CHECKED);
        List<VerificationStateInfo> verificationStateInfoList = new ArrayList<>();
        verificationStateInfoList.add(verificationStateInfo);
        testReleaseVulnerabilityRelation.setVerificationStateInfo(verificationStateInfoList);

        // Setup object mapper
        objectMapper = new ObjectMapper();

        // Setup user mock
        User user = TestHelper.getTestUser();
        given(this.userServiceMock.getUserByEmailOrExternalId("admin@sw360.org")).willReturn(user);

        // Setup vulnerability service mocks
        List<Vulnerability> vulnerabilityList = Arrays.asList(testVulnerability);
        Map<PaginationData, List<Vulnerability>> paginatedVulnerabilities = new HashMap<>();
        PaginationData paginationData = new PaginationData();
        paginationData.setRowsPerPage(10);
        paginationData.setDisplayStart(0);
        paginationData.setTotalRowCount(1);
        paginatedVulnerabilities.put(paginationData, vulnerabilityList);

        given(this.vulnerabilityServiceMock.getVulnerabilities(any(), any())).willReturn(paginatedVulnerabilities);
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq("CVE-2023-1234"), any())).willReturn(testVulnerability);
        given(this.vulnerabilityServiceMock.getObjectMapper()).willReturn(objectMapper);
        doNothing().when(vulnerabilityServiceMock).createUpdateDeleteVulnerability(any(), any(), any());
        doNothing().when(vulnerabilityServiceMock).createUpdateDeleteVulnerabilityReleaseRelation(any(), any(), any());
    }

    // ========== GET VULNERABILITIES TESTS ==========

    @Test
    public void should_get_all_vulnerabilities() throws IOException {
        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities",
                        HttpMethod.GET,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain vulnerabilities", responseBody.contains("_embedded"));
        assertTrue("Response should contain vulnerability data", responseBody.contains("CVE-2023-1234"));
    }

    @Test
    public void should_get_vulnerabilities_with_pagination() throws IOException {
        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities?page=0&page_entries=5&sort=priority,desc",
                        HttpMethod.GET,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain pagination info", responseBody.contains("page"));
        assertTrue("Response should contain vulnerability data", responseBody.contains("CVE-2023-1234"));
    }

    @Test
    public void should_get_vulnerabilities_with_search() throws IOException {
        // Mock search functionality
        List<Vulnerability> searchResults = Arrays.asList(testVulnerability);
        Map<PaginationData, List<Vulnerability>> searchPaginatedResults = new HashMap<>();
        PaginationData paginationData = new PaginationData();
        paginationData.setRowsPerPage(10);
        paginationData.setDisplayStart(0);
        paginationData.setTotalRowCount(1);
        searchPaginatedResults.put(paginationData, searchResults);

        given(this.vulnerabilityServiceMock.searchVulnerabilities(eq("test"), any(), any())).willReturn(searchPaginatedResults);

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities?search=test",
                        HttpMethod.GET,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain search results", responseBody.contains("CVE-2023-1234"));
    }

    // ========== GET SINGLE VULNERABILITY TESTS ==========

    @Test
    public void should_get_vulnerability_by_external_id() throws IOException {
        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-1234",
                        HttpMethod.GET,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain vulnerability title", responseBody.contains("Test Vulnerability"));
        assertTrue("Response should contain external ID", responseBody.contains("CVE-2023-1234"));
        assertTrue("Response should contain priority", responseBody.contains("high"));
    }

    @Test
    public void should_handle_vulnerability_not_found() throws IOException {
        // Mock service to throw ResourceNotFoundException
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq("NONEXISTENT"), any()))
                .willThrow(new org.springframework.data.rest.webmvc.ResourceNotFoundException("Vulnerability not found"));

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/NONEXISTENT",
                        HttpMethod.GET,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
    }

    // ========== CREATE VULNERABILITY TESTS ==========

    @Test
    public void should_create_vulnerability() throws IOException {
        // Mock service to not find existing vulnerability (to avoid conflict)
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq("CVE-2023-5678"), any()))
                .willThrow(new org.springframework.data.rest.webmvc.ResourceNotFoundException("Vulnerability not found"));

        Map<String, Object> vulnerabilityData = new HashMap<>();
        vulnerabilityData.put("externalId", "CVE-2023-5678");
        vulnerabilityData.put("title", "New Test Vulnerability");
        vulnerabilityData.put("description", "New vulnerability description");
        vulnerabilityData.put("cwe", "CWE-80");
        vulnerabilityData.put("priority", "medium");
        vulnerabilityData.put("action", "new");
        vulnerabilityData.put("cvss", "5.5");
        vulnerabilityData.put("publishDate", "2023-02-01");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(vulnerabilityData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities",
                        HttpMethod.POST,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain created vulnerability data", responseBody.contains("CVE-2023-5678"));
        assertTrue("Response should contain title", responseBody.contains("New Test Vulnerability"));
    }

    @Test
    public void should_fail_create_vulnerability_without_external_id() throws IOException {
        Map<String, Object> vulnerabilityData = new HashMap<>();
        vulnerabilityData.put("title", "Vulnerability without external ID");
        vulnerabilityData.put("description", "This should fail");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(vulnerabilityData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities",
                        HttpMethod.POST,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain error about external ID", responseBody.contains("External Id should not be null or empty"));
    }

    @Test
    public void should_fail_create_vulnerability_with_duplicate_external_id() throws IOException {
        // Mock service to return existing vulnerability (simulating duplicate)
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq("CVE-2023-1234"), any()))
                .willReturn(testVulnerability);

        Map<String, Object> vulnerabilityData = new HashMap<>();
        vulnerabilityData.put("externalId", "CVE-2023-1234");
        vulnerabilityData.put("title", "Duplicate Vulnerability");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(vulnerabilityData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities",
                        HttpMethod.POST,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain conflict error", responseBody.contains("Conflict Vulnerability with same external id"));
    }

    // ========== UPDATE VULNERABILITY TESTS ==========

    @Test
    public void should_update_vulnerability() throws IOException {
        Map<String, Object> updateData = new HashMap<>();
        updateData.put("externalId", "CVE-2023-1234");
        updateData.put("title", "Updated Test Vulnerability");
        updateData.put("description", "Updated vulnerability description");
        updateData.put("priority", "critical");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(updateData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-1234",
                        HttpMethod.PATCH,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain updated vulnerability data", responseBody.contains("CVE-2023-1234"));
        assertTrue("Response should contain updated title", responseBody.contains("Updated Test Vulnerability"));
    }

    @Test
    public void should_fail_update_vulnerability_with_mismatched_external_id() throws IOException {
        Map<String, Object> updateData = new HashMap<>();
        updateData.put("externalId", "CVE-2023-DIFFERENT");
        updateData.put("title", "Mismatched Vulnerability");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(updateData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-1234",
                        HttpMethod.PATCH,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain error about external ID mismatch", responseBody.contains("External Id is not correct"));
    }

    @Test
    public void should_fail_update_vulnerability_with_empty_external_id() throws IOException {
        Map<String, Object> updateData = new HashMap<>();
        updateData.put("externalId", "");
        updateData.put("title", "Empty External ID Vulnerability");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(updateData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/",
                        HttpMethod.PATCH,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
    }

    // ========== DELETE VULNERABILITY TESTS ==========

    @Test
    public void should_delete_vulnerability() throws IOException {
        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-1234",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.MULTI_STATUS, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain deletion status", responseBody.contains("resourceId"));
        assertTrue("Response should contain status", responseBody.contains("status"));
    }

    @Test
    public void should_handle_delete_nonexistent_vulnerability() throws IOException {
        // Mock service to throw ResourceNotFoundException for delete
        doThrow(new org.springframework.data.rest.webmvc.ResourceNotFoundException("Vulnerability not found"))
                .when(vulnerabilityServiceMock).createUpdateDeleteVulnerability(any(), any(), any());

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/NONEXISTENT",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.MULTI_STATUS, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    // ========== RELEASE VULNERABILITY RELATION TESTS ==========

    @Test
    public void should_create_release_vulnerability_relation() throws IOException {
        Map<String, Object> relationData = new HashMap<>();
        relationData.put("releaseId", "release123");
        relationData.put("vulnerabilityId", "12345");
        relationData.put("matchedBy", "manual");
        relationData.put("usedNeedle", "CVE-2023-1234");

        Map<String, Object> verificationStateInfo = new HashMap<>();
        verificationStateInfo.put("checkedBy", "admin@sw360.org");
        verificationStateInfo.put("checkedOn", "2023-01-01");
        verificationStateInfo.put("comment", "Test verification");
        verificationStateInfo.put("verificationState", "CHECKED");
        relationData.put("verificationStateInfo", verificationStateInfo);

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(relationData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-1234/releaseVulnerabilityRelation",
                        HttpMethod.POST,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
    }

    @Test
    public void should_delete_release_vulnerability_relation() throws IOException {
        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-1234/release/release123",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
    }

    // ========== VULNERABILITY TRACKING STATUS TESTS ==========

    @Test
    public void should_get_vulnerabilities_tracking_status() throws IOException, TException {
        // Setup tracking status data
        List<ReleaseClearingStatusData> clearingStatusList = new ArrayList<>();
        ReleaseClearingStatusData statusData = new ReleaseClearingStatusData();
        clearingStatusList.add(statusData);

        given(this.vulnerabilityServiceMock.getReleasesClearingStatusWithAccessibility(any(), eq("project123")))
                .willReturn(clearingStatusList);

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/trackingStatus/project123?page=0&page_entries=5&sortBy=name&sortOrder=desc",
                        HttpMethod.GET,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());

        String responseBody = response.getBody();
        assertTrue("Response should contain vulnerability tracking status", responseBody.contains("vulnerabilityTrackingStatus"));
        assertTrue("Response should contain pagination info", responseBody.contains("page"));
        assertTrue("Response should contain totalElements", responseBody.contains("totalElements"));
    }

    // ========== EXCEPTION COVERAGE TESTS ==========

    @Test
    public void should_handle_exception_in_get_vulnerabilities() throws IOException {
        // Mock service to throw exception
        given(this.vulnerabilityServiceMock.getVulnerabilities(any(), any()))
                .willThrow(new RuntimeException("Database connection failed"));

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities",
                        HttpMethod.GET,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
    }

    @Test
    public void should_handle_exception_in_create_vulnerability() throws IOException {
        // Mock service to throw exception during creation
        doThrow(new RuntimeException("Creation failed"))
                .when(vulnerabilityServiceMock).createUpdateDeleteVulnerability(any(), any(), any());

        Map<String, Object> vulnerabilityData = new HashMap<>();
        vulnerabilityData.put("externalId", "CVE-2023-EXCEPTION");
        vulnerabilityData.put("title", "Exception Test Vulnerability");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(vulnerabilityData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities",
                        HttpMethod.POST,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
    }

    @Test
    public void should_handle_exception_in_update_vulnerability() throws IOException {
        // Mock service to throw exception during update
        doThrow(new RuntimeException("Update failed"))
                .when(vulnerabilityServiceMock).createUpdateDeleteVulnerability(any(), any(), any());

        Map<String, Object> updateData = new HashMap<>();
        updateData.put("externalId", "CVE-2023-1234");
        updateData.put("title", "Exception Update Test");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(updateData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-1234",
                        HttpMethod.PATCH,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
    }

    @Test
    public void should_handle_exception_in_delete_vulnerability() throws IOException {
        // Mock service to throw exception during deletion
        doThrow(new RuntimeException("Deletion failed"))
                .when(vulnerabilityServiceMock).createUpdateDeleteVulnerability(any(), any(), any());

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-1234",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.MULTI_STATUS, response.getStatusCode());
    }

    @Test
    public void should_handle_exception_in_create_release_vulnerability_relation() throws IOException {
        // Mock service to throw exception during relation creation
        doThrow(new RuntimeException("Relation creation failed"))
                .when(vulnerabilityServiceMock).createUpdateDeleteVulnerabilityReleaseRelation(any(), any(), any());

        Map<String, Object> relationData = new HashMap<>();
        relationData.put("releaseId", "release123");
        relationData.put("vulnerabilityId", "12345");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(relationData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-1234/releaseVulnerabilityRelation",
                        HttpMethod.POST,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
    }

    @Test
    public void should_handle_exception_in_get_tracking_status() throws IOException, TException {
        // Mock service to throw exception during tracking status retrieval
        given(this.vulnerabilityServiceMock.getReleasesClearingStatusWithAccessibility(any(), eq("project123")))
                .willThrow(new RuntimeException("Tracking status retrieval failed"));

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/trackingStatus/project123",
                        HttpMethod.GET,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
    }

    // Additional tests to cover uncovered lines
    private static @NotNull VulnerabilityWithReleaseRelations getVulnerabilityWithReleaseRelations(String externalId, String vuln999, String release999) {
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = new VulnerabilityWithReleaseRelations();
        Vulnerability vulnerability = new Vulnerability();
        vulnerability.setExternalId(externalId);
        vulnerability.setId(vuln999);
        vulnerabilityWithReleaseRelations.setVulnerability(vulnerability);

        List<ReleaseVulnerabilityRelation> relations = new ArrayList<>();
        ReleaseVulnerabilityRelation relation = new ReleaseVulnerabilityRelation();
        relation.setReleaseId(release999);
        relations.add(relation);
        vulnerabilityWithReleaseRelations.setReleaseRelation(relations);
        return vulnerabilityWithReleaseRelations;
    }

    @Test
    public void should_delete_vulnerability_with_release_relations_but_empty_releases() throws IOException, TException {
        // Mock vulnerability with release relations but empty releases list
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = getVulnerabilityWithReleaseRelations("CVE-2023-9999", "vuln999", "release999");

        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq("CVE-2023-9999"), any()))
                .willReturn(vulnerabilityWithReleaseRelations);

        // Mock release service to return null (release not found)
        given(this.releaseServiceMock.getReleaseForUserById(eq("release999"), any()))
                .willReturn(null);

        // Mock successful deletion
        doNothing().when(vulnerabilityServiceMock).createUpdateDeleteVulnerability(any(), any(), eq(VulnerabilityOperation.DELETE));

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-9999",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.MULTI_STATUS, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue("Response should contain OK status", response.getBody().contains("\"status\" : 200"));
    }

    @Test
    public void should_fail_delete_vulnerability_with_active_release_relations() throws IOException, TException {
        // Mock vulnerability with active release relations
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = getVulnerabilityWithReleaseRelations("CVE-2023-8888", "vuln888", "release888");

        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq("CVE-2023-8888"), any()))
                .willReturn(vulnerabilityWithReleaseRelations);

        // Mock release service to return a valid release
        Release release = new Release();
        release.setId("release888");
        release.setName("Test Release");
        given(this.releaseServiceMock.getReleaseForUserById(eq("release888"), any()))
                .willReturn(release);

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-8888",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.MULTI_STATUS, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue("Response should contain FORBIDDEN status", response.getBody().contains("\"status\" : 403"));
    }

    @Test
    public void should_fail_create_vulnerability_release_relation_when_already_exists() throws IOException, TException {
        // Mock vulnerability with existing release relation
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = getVulnerabilityWithReleaseRelations("CVE-2023-7777", "vuln777", "release777");

        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq("CVE-2023-7777"), any()))
                .willReturn(vulnerabilityWithReleaseRelations);

        // Mock release service
        Release release = new Release();
        release.setId("release777");
        given(this.releaseServiceMock.getReleaseForUserById(eq("release777"), any()))
                .willReturn(release);

        Map<String, Object> relationData = new HashMap<>();
        relationData.put("releaseId", "release777");

        HttpHeaders headers = getHeaders(port);
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(relationData, headers);

        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-7777/releaseVulnerabilityRelation",
                        HttpMethod.POST,
                        requestEntity,
                        String.class);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue("Response should contain relation already exists message",
                response.getBody().contains("Vulnerability Release Relation already exists"));
    }

    @Test
    public void should_handle_http_message_not_readable_exception_in_delete_relation() throws IOException, TException {
        // Mock vulnerability with release relation
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = getVulnerabilityWithReleaseRelations("CVE-2023-6666", "vuln666", "release666");

        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq("CVE-2023-6666"), any()))
                .willReturn(vulnerabilityWithReleaseRelations);

        // Mock release service
        Release release = new Release();
        release.setId("release666");
        given(this.releaseServiceMock.getReleaseForUserById(eq("release666"), any()))
                .willReturn(release);

        // Mock service to throw BadRequestClientException
        doThrow(new BadRequestClientException("Invalid message format"))
                .when(vulnerabilityServiceMock).createUpdateDeleteVulnerabilityReleaseRelation(any(), any(), any());

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-6666/release/release666",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.MULTI_STATUS, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue("Response should contain BAD_REQUEST status", response.getBody().contains("\"status\" : 400"));
    }

    @Test
    public void should_handle_bad_request_client_exception_in_delete_relation() throws IOException, TException {
        // Mock vulnerability with release relation
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = getVulnerabilityWithReleaseRelations("CVE-2023-5555", "vuln555", "release555");

        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq("CVE-2023-5555"), any()))
                .willReturn(vulnerabilityWithReleaseRelations);

        // Mock release service
        Release release = new Release();
        release.setId("release555");
        given(this.releaseServiceMock.getReleaseForUserById(eq("release555"), any()))
                .willReturn(release);

        // Mock service to throw BadRequestClientException
        doThrow(new BadRequestClientException("Invalid request data"))
                .when(vulnerabilityServiceMock).createUpdateDeleteVulnerabilityReleaseRelation(any(), any(), any());

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-5555/release/release555",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.MULTI_STATUS, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue("Response should contain BAD_REQUEST status", response.getBody().contains("\"status\" : 400"));
    }

    @Test
    public void should_handle_access_denied_exception_in_delete_relation() throws IOException, TException {
        // Mock vulnerability with release relation
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = getVulnerabilityWithReleaseRelations("CVE-2023-4444", "vuln444", "release444");

        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq("CVE-2023-4444"), any()))
                .willReturn(vulnerabilityWithReleaseRelations);

        // Mock release service
        Release release = new Release();
        release.setId("release444");
        given(this.releaseServiceMock.getReleaseForUserById(eq("release444"), any()))
                .willReturn(release);

        // Mock service to throw AccessDeniedException
        doThrow(new AccessDeniedException("Access denied"))
                .when(vulnerabilityServiceMock).createUpdateDeleteVulnerabilityReleaseRelation(any(), any(), any());

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-4444/release/release444",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.MULTI_STATUS, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue("Response should contain FORBIDDEN status", response.getBody().contains("\"status\" : 403"));
    }

    @Test
    public void should_handle_runtime_exception_in_delete_relation() throws IOException, TException {
        // Mock vulnerability with release relation
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = getVulnerabilityWithReleaseRelations("CVE-2023-3333", "vuln333", "release333");

        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq("CVE-2023-3333"), any()))
                .willReturn(vulnerabilityWithReleaseRelations);

        // Mock release service
        Release release = new Release();
        release.setId("release333");
        given(this.releaseServiceMock.getReleaseForUserById(eq("release333"), any()))
                .willReturn(release);

        // Mock service to throw RuntimeException
        doThrow(new RuntimeException("Internal server error"))
                .when(vulnerabilityServiceMock).createUpdateDeleteVulnerabilityReleaseRelation(any(), any(), any());

        HttpHeaders headers = getHeaders(port);
        ResponseEntity<String> response =
                new TestRestTemplate().exchange("http://localhost:" + port + "/api/vulnerabilities/CVE-2023-3333/release/release333",
                        HttpMethod.DELETE,
                        new HttpEntity<>(null, headers),
                        String.class);

        assertEquals(HttpStatus.MULTI_STATUS, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue("Response should contain INTERNAL_SERVER_ERROR status", response.getBody().contains("\"status\" : 500"));
    }
}
