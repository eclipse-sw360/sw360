/*
 * Copyright Bosch Software Innovations GmbH, 2017.
 * With modifications by Siemens AG, 2018.
 * Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.rest.resourceserver.vulnerability;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.HashSet;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Collectors;

import jakarta.servlet.http.HttpServletRequest;


import org.apache.thrift.TException;
import org.eclipse.sw360.datahandler.common.CommonUtils;
import org.eclipse.sw360.datahandler.common.SW360Constants;
import org.eclipse.sw360.datahandler.permissions.DocumentPermissions;
import org.eclipse.sw360.datahandler.resourcelists.PaginationParameterException;
import org.eclipse.sw360.datahandler.resourcelists.PaginationResult;
import org.eclipse.sw360.datahandler.resourcelists.ResourceClassNotFoundException;
import org.eclipse.sw360.datahandler.thrift.PaginationData;
import org.eclipse.sw360.datahandler.thrift.SW360Exception;
import org.eclipse.sw360.datahandler.thrift.components.Release;
import org.eclipse.sw360.datahandler.thrift.components.ReleaseClearingStatusData;
import org.eclipse.sw360.datahandler.thrift.users.RequestedAction;
import org.eclipse.sw360.datahandler.thrift.users.User;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.ReleaseVulnerabilityRelation;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.VulnerabilityApiDTO;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.VulnerabilityWithReleaseRelations;
import org.eclipse.sw360.rest.resourceserver.core.BadRequestClientException;
import org.eclipse.sw360.rest.resourceserver.core.HalResource;
import org.eclipse.sw360.rest.resourceserver.core.MultiStatus;
import org.eclipse.sw360.rest.resourceserver.core.OpenAPIPaginationHelper;
import org.eclipse.sw360.rest.resourceserver.core.RestControllerHelper;
import org.eclipse.sw360.rest.resourceserver.release.Sw360ReleaseService;
import org.springframework.data.domain.Pageable;
import org.eclipse.sw360.rest.resourceserver.vulnerability.Sw360VulnerabilityService.VulnerabilityOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.rest.webmvc.BasePathAwareController;
import org.springframework.data.rest.webmvc.RepositoryLinksResource;
import org.springframework.data.rest.webmvc.ResourceNotFoundException;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.RepresentationModelProcessor;
import org.springframework.hateoas.CollectionModel;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.Lists;

import static org.eclipse.sw360.datahandler.permissions.PermissionUtils.makePermission;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;

@BasePathAwareController
@Slf4j
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
@RestController
@SecurityRequirement(name = "tokenAuth")
@SecurityRequirement(name = "basic")
public class VulnerabilityController implements RepresentationModelProcessor<RepositoryLinksResource> {
    static final String VULNERABILITIES_URL = "/vulnerabilities";

    @NonNull
    private final Sw360VulnerabilityService vulnerabilityService;

    @NonNull
    private final RestControllerHelper restControllerHelper;

    @NonNull
    private Sw360ReleaseService releaseService;

    @Operation(
            summary = "List all of the service's vulnerabilities.",
            description = "List all of the service's vulnerabilities.",
            tags = {"Vulnerabilities"}
    )
    @GetMapping(value = VULNERABILITIES_URL)
    public ResponseEntity<CollectionModel<EntityModel<VulnerabilityApiDTO>>> getVulnerabilities(
            @Parameter(description = "Filter for External Id or Title")
            @RequestParam(value = "search", required = false) String searchText,
            @Parameter(description = "Filter for CVE ID")
            @RequestParam(value = "cveId", required = false) String cveId,
            @Parameter(description = "Pagination requests", schema = @Schema(implementation = OpenAPIPaginationHelper.class))
            Pageable pageable,
            HttpServletRequest request
    ) throws URISyntaxException, PaginationParameterException, ResourceClassNotFoundException {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        Map<PaginationData, List<Vulnerability>> paginatedVulnerabilities = null;
        if (CommonUtils.isNotNullEmptyOrWhitespace(searchText) || CommonUtils.isNotNullEmptyOrWhitespace(cveId)) {
            paginatedVulnerabilities = vulnerabilityService.searchVulnerabilities(searchText, cveId, user, pageable);
        } else {
            paginatedVulnerabilities = vulnerabilityService.getVulnerabilities(user, pageable);
        }

        PaginationResult<Vulnerability> paginationResult = null;
        List<Vulnerability> vulnerabilities = new ArrayList<>(paginatedVulnerabilities.values().iterator().next());
        int totalCount = Math.toIntExact(paginatedVulnerabilities.keySet().stream()
                .findFirst().map(PaginationData::getTotalRowCount).orElse(0L));

        paginationResult = restControllerHelper.paginationResultFromPaginatedList(
                request, pageable, vulnerabilities, SW360Constants.TYPE_VULNERABILITY, totalCount);

        List<EntityModel<VulnerabilityApiDTO>> vulnResources = Lists.newArrayList();
        for (Vulnerability v: paginationResult.getResources()) {
            Set<Release> releaseList = getReleaseRelationsInfo(v, user);
            VulnerabilityApiDTO vulnerabilityApiDTO = new VulnerabilityApiDTO();
            restControllerHelper.setDataVulApiDTO(vulnerabilityApiDTO, v, releaseList);
            vulnResources.add(EntityModel.of(vulnerabilityApiDTO));
        }

        CollectionModel<EntityModel<VulnerabilityApiDTO>> resources;
        if (vulnerabilities.isEmpty()) {
            resources = restControllerHelper.emptyPageResource(Vulnerability.class, paginationResult);
        } else {
            resources = restControllerHelper.generatePagesResource(paginationResult, vulnResources);
        }

        HttpStatus status = resources == null ? HttpStatus.NO_CONTENT : HttpStatus.OK;
        return new ResponseEntity<>(resources, status);
    }

    @Operation(
            summary = "Get a vulnerability by the external ID.",
            description = "Get a vulnerability by the external ID.",
            tags = {"Vulnerabilities"}
    )
    @GetMapping(VULNERABILITIES_URL + "/{id}")
    public ResponseEntity<HalResource<VulnerabilityApiDTO>> getVulnerability(
            @Parameter(description = "The external ID of the vulnerability to be retrieved.")
            @PathVariable("id") String id
    ) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        Vulnerability vulnerability = vulnerabilityService.getVulnerabilityByExternalId(id, user);
        Set<Release> releaseList = getReleaseRelationsInfo(vulnerability, user);
        VulnerabilityApiDTO vulnerabilityApiDTO = new VulnerabilityApiDTO();
        restControllerHelper.setDataVulApiDTO(vulnerabilityApiDTO, vulnerability, releaseList);
        HalResource<VulnerabilityApiDTO> vulnerabilityHalResource = createHalVulnerability(vulnerabilityApiDTO, user);

        return new ResponseEntity<>(vulnerabilityHalResource, HttpStatus.OK);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @Operation(
            summary = "Create a new vulnerability.",
            description = "Create a new vulnerability.",
            tags = {"Vulnerabilities"},
            responses = {
                    @ApiResponse(
                            responseCode = "201",
                            content = @Content(mediaType = "application/hal+json",
                                    schema = @Schema(implementation = VulnerabilityApiDTO.class)),
                            description = "Redirection to the created vulnerability."
                    )
            }
    )
    @PostMapping(VULNERABILITIES_URL)
    public ResponseEntity createVulnerability(
            @Parameter(description = "The vulnerability to be created.",
                    schema = @Schema(implementation = VulnerabilityApiDTO.class)
            )
            @RequestBody Map<String, Object> vulnerabilityAsMap
    ) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        ObjectMapper mapper = vulnerabilityService.getObjectMapper();
        VulnerabilityApiDTO vulnerabilityApiDTO = mapper.convertValue(vulnerabilityAsMap, VulnerabilityApiDTO.class);
        String externalId = vulnerabilityApiDTO.getExternalId();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId)) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, "External Id should not be null or empty");
        }

        try {
            vulnerabilityService.getVulnerabilityByExternalId(externalId, user);
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, "Conflict Vulnerability with same external id " +
                    "already exists.");
        } catch (ResourceNotFoundException ignored) {
        }
        Vulnerability vulnerability = new Vulnerability(externalId);
        restControllerHelper.setDataForVulnerability(vulnerabilityApiDTO, vulnerability);

        vulnerabilityService.createUpdateDeleteVulnerability(vulnerability, user, VulnerabilityOperation.CREATE);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(externalId)
                .toUri();

        return ResponseEntity.created(location).body(vulnerabilityAsMap);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @Operation(
            summary = "Update a vulnerability.",
            description = "Update a vulnerability.",
            tags = {"Vulnerabilities"},
            responses = {
                    @ApiResponse(
                            responseCode = "200",
                            content = @Content(mediaType = "application/hal+json",
                                    schema = @Schema(implementation = VulnerabilityApiDTO.class)),
                            description = "Updated vulnerability."
                    )
            }
    )
    @PatchMapping(VULNERABILITIES_URL + "/{externalId}")
    public ResponseEntity updateVulnerability(
            @Parameter(description = "The external ID of the vulnerability to be updated.")
            @PathVariable String externalId,
            @Parameter(description = "The updated vulnerability.",
                    schema = @Schema(implementation = VulnerabilityApiDTO.class)
            )
            @RequestBody Map<String, Object> vulnerabilityAsMap
    ) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        ObjectMapper mapper = vulnerabilityService.getObjectMapper();
        VulnerabilityApiDTO vulnerabilityApiDTO = mapper.convertValue(vulnerabilityAsMap, VulnerabilityApiDTO.class);
        if (CommonUtils.isNullEmptyOrWhitespace(externalId)) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, "External Id should not be null or empty");
        }
        if (!externalId.equals(vulnerabilityApiDTO.getExternalId())) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, "External Id is not correct");
        }
        Vulnerability vulnerability = new Vulnerability(externalId);
        restControllerHelper.setDataForVulnerability(vulnerabilityApiDTO, vulnerability);

        Vulnerability vulnerabilityByExtId = vulnerabilityService.getVulnerabilityByExternalId(externalId, user);
        vulnerabilityService.updateFromVulnerabilityDTO(vulnerabilityByExtId, vulnerability, vulnerabilityApiDTO);
        vulnerabilityService.createUpdateDeleteVulnerability(vulnerabilityByExtId, user, VulnerabilityOperation.UPDATE);

        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        return ResponseEntity.ok(mapper.convertValue(vulnerabilityAsMap, Map.class));
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @Operation(
            summary = "Delete a vulnerability.",
            description = "Delete a vulnerability.",
            tags = {"Vulnerabilities"},
            responses = {
                    @ApiResponse(
                            responseCode = "207",
                            content = @Content(mediaType = "application/hal+json",
                                    schema = @Schema(type = "array",
                                            implementation = MultiStatus.class)),
                            description = "External ID and status."
                    )
            }
    )
    @DeleteMapping(VULNERABILITIES_URL + "/{externalId}")
    public ResponseEntity deleteVulnerability(
            @Parameter(description = "The external ID of the vulnerability to be deleted.")
            @PathVariable String externalId
    ) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        List<MultiStatus> results = new ArrayList<>();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId)) {
            results.add(new MultiStatus(externalId, HttpStatus.BAD_REQUEST));
            log.error("External Id should not be null or empty");
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        try {
            VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService.getVulnerabilityWithReleaseRelations(externalId, user);
            if (!CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
                vulnerabilityService.createUpdateDeleteVulnerability(vulnerabilityWithReleaseRelations.getVulnerability(),
                        user, VulnerabilityOperation.DELETE);
            } else {
                List<Release> releasesInRelation = new ArrayList<>();
                Set<String> releaseIdsInRelation = vulnerabilityWithReleaseRelations.getReleaseRelation().stream()
                        .map(ReleaseVulnerabilityRelation::getReleaseId)
                        .collect(Collectors.toSet());

                releaseIdsInRelation.stream().forEach(releaseId -> {
                    try {
                        Release release = releaseService.getReleaseForUserById(releaseId, user);
                        if (release != null) {
                            releasesInRelation.add(release);
                        }
                    } catch (TException | ResourceNotFoundException e) {
                        log.error("Error when get release: " + releaseId + ". " + e.getMessage());
                    }
                });

                if (releasesInRelation.isEmpty()) {
                    vulnerabilityService.createUpdateDeleteVulnerability(vulnerabilityWithReleaseRelations.getVulnerability(),
                            user, VulnerabilityOperation.DELETE);
                } else {
                    String releaseIds = vulnerabilityWithReleaseRelations.getReleaseRelation().stream().filter(Objects::nonNull)
                            .map(ReleaseVulnerabilityRelation::getReleaseId).filter(CommonUtils::isNotNullEmptyOrWhitespace)
                            .collect(Collectors.joining(", "));
                    log.error("Vulnerability used/linked to releases : " + releaseIds);
                    results.add(new MultiStatus(externalId, HttpStatus.FORBIDDEN));
                    return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
                }
            }
        } catch (ResourceNotFoundException notFoundException) {
            results.add(new MultiStatus(externalId, HttpStatus.NOT_FOUND));
            log.error(notFoundException.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (AccessDeniedException accessDeniedException) {
            results.add(new MultiStatus(externalId, HttpStatus.FORBIDDEN));
            log.error(accessDeniedException.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (RuntimeException runtimeException) {
            results.add(new MultiStatus(externalId, HttpStatus.INTERNAL_SERVER_ERROR));
            log.error(runtimeException.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        results.add(new MultiStatus(externalId, HttpStatus.OK));
        return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @Operation(
            summary = "Create a new vulnerability to release relation.",
            description = "Create a new vulnerability to release relation.",
            tags = {"Vulnerabilities"},
            responses = {
                    @ApiResponse(
                            responseCode = "200",
                            content = @Content(mediaType = "application/hal+json",
                                    schema = @Schema(implementation = ReleaseVulnerabilityRelation.class)),
                            description = "Updated relation information."
                    )
            }
    )
    @PostMapping(value = VULNERABILITIES_URL + "/{externalId}/releaseVulnerabilityRelation")
    public ResponseEntity postVulnerabilityToReleases(
            @Parameter(description = "The external ID of the vulnerability to be linked to a release.")
            @PathVariable String externalId,
            @Parameter(description = "The release to be linked to a vulnerability.")
            @RequestBody ReleaseVulnerabilityRelation releaseVulnerabilityRelation
    ) throws TException {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        String releaseId = releaseVulnerabilityRelation.getReleaseId();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId) || CommonUtils.isNullEmptyOrWhitespace(releaseId)) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, "External Id or Release Id should not be null or empty");
        }
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService
                .getVulnerabilityWithReleaseRelations(externalId, user);

        Release releaseForUserById = releaseService.getReleaseForUserById(releaseId, user);
        DocumentPermissions<Release> permissions = makePermission(releaseForUserById, user);
        if (!permissions.isActionAllowed(RequestedAction.WRITE)) {
            throw new AccessDeniedException("User does not have write access to release : " + releaseId);
        }

        long count = 0;
        if (CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
            count = vulnerabilityWithReleaseRelations.getReleaseRelation().stream().filter(Objects::nonNull)
                    .map(ReleaseVulnerabilityRelation::getReleaseId).filter(CommonUtils::isNotNullEmptyOrWhitespace)
                    .filter(relationReleaseId -> relationReleaseId.equals(releaseId)).count();
        }
        if (count == 0) {
            releaseVulnerabilityRelation
                    .setVulnerabilityId(vulnerabilityWithReleaseRelations.getVulnerability().getId());
            vulnerabilityService.createUpdateDeleteVulnerabilityReleaseRelation(releaseVulnerabilityRelation, user,
                    VulnerabilityOperation.CREATE);
        } else {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, "Vulnerability Release Relation already exists");
        }
        return ResponseEntity.ok().body(releaseVulnerabilityRelation);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @Operation(
            summary = "Delete a release vulnerability relation.",
            description = "Delete a release vulnerability relation.",
            tags = {"Vulnerabilities"},
            responses = {
                    @ApiResponse(
                            responseCode = "200",
                            content = @Content(mediaType = "application/hal+json",
                                    schema = @Schema(implementation = ReleaseVulnerabilityRelation.class)),
                            description = "Updated relation information."
                    )
            }
    )
    @DeleteMapping(value = VULNERABILITIES_URL + "/{externalId}/release/{releaseId}")
    public ResponseEntity deleteVulnerabilityToReleasesRelation(
            @Parameter(description = "The external ID of the vulnerability.")
            @PathVariable(value = "externalId") String externalId,
            @Parameter(description = "The release to be unlinked.")
            @PathVariable(value = "releaseId") String releaseId
    ) throws TException {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        List<MultiStatus> results = new ArrayList<>();
        String resourceId = externalId + " - " + releaseId;

        if (CommonUtils.isNullEmptyOrWhitespace(externalId) || CommonUtils.isNullEmptyOrWhitespace(releaseId)) {
            results.add(new MultiStatus(resourceId, HttpStatus.BAD_REQUEST));
            log.error("External Id should not be null or empty");
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService
                .getVulnerabilityWithReleaseRelations(externalId, user);

        Release releaseForUserById = releaseService.getReleaseForUserById(releaseId, user);
        DocumentPermissions<Release> permissions = makePermission(releaseForUserById, user);

        if (!permissions.isActionAllowed(RequestedAction.WRITE)) {
            results.add(new MultiStatus(resourceId, HttpStatus.FORBIDDEN));
            log.error("User does not have write access to release : " + releaseId);
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        Optional<ReleaseVulnerabilityRelation> releaseVulnerabilityRelationOpt = null;
        if (CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
            releaseVulnerabilityRelationOpt = vulnerabilityWithReleaseRelations.getReleaseRelation().stream()
                    .filter(Objects::nonNull).filter(vulRelRelation -> releaseId.equals(vulRelRelation.getReleaseId()))
                    .findFirst();
        }

        if (releaseVulnerabilityRelationOpt == null || releaseVulnerabilityRelationOpt.isEmpty()) {
            results.add(new MultiStatus(resourceId, HttpStatus.NOT_FOUND));
            log.error("Vulnerability Release Relation does not exists");
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        try {
            vulnerabilityService.createUpdateDeleteVulnerabilityReleaseRelation(releaseVulnerabilityRelationOpt.get(),
                    user, VulnerabilityOperation.DELETE);
            results.add(new MultiStatus(resourceId, HttpStatus.OK));
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (HttpMessageNotReadableException | BadRequestClientException ex) {
            results.add(new MultiStatus(resourceId, HttpStatus.BAD_REQUEST));
            log.error(ex.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (AccessDeniedException accessDeniedException) {
            results.add(new MultiStatus(resourceId, HttpStatus.FORBIDDEN));
            log.error("User does not have write access to release : " + releaseId);
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (RuntimeException runtimeException) {
            results.add(new MultiStatus(resourceId, HttpStatus.INTERNAL_SERVER_ERROR));
            log.error(runtimeException.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }
    }

    @Override
    public RepositoryLinksResource process(RepositoryLinksResource resource) {
        resource.add(linkTo(VulnerabilityController.class).slash("api" + VULNERABILITIES_URL).withRel("vulnerabilities"));
        return resource;
    }

    private HalResource<VulnerabilityApiDTO> createHalVulnerability(VulnerabilityApiDTO vulnerabilityApiDTO, User user) {
        return new HalResource<>(vulnerabilityApiDTO);
    }

    private Set<Release> getReleaseRelationsInfo(Vulnerability vulnerability, User user) {
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService
                .getVulnerabilityWithReleaseRelations(vulnerability.getExternalId(), user);
        Set<Release> releaseList = new HashSet<Release>();
        if(vulnerabilityWithReleaseRelations == null) {
            return releaseList;
        }

        List<ReleaseVulnerabilityRelation> releaseRelations = vulnerabilityWithReleaseRelations.getReleaseRelation();
        for (ReleaseVulnerabilityRelation releaseRelation :releaseRelations) {
            String releaseId = releaseRelation.getReleaseId();
            try {
                Release releaseForUserById = releaseService.getReleaseForUserById(releaseId, user);
                releaseList.add(releaseForUserById);
            } catch (TException |ResourceNotFoundException e) {
                log.error("Error when get release " + releaseId + " " + e.getMessage());
            }
        }

        return releaseList;
    }

    @Operation(
            summary = "Get vulnerability tracking status for project.",
            description = "Get vulnerability tracking status for project.",
            tags = {"Vulnerabilities"},
            responses = {
                    @ApiResponse(
                            responseCode = "200",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(type = "array",
                                            example = "[\n" +
                                                    "{\n" +
                                                    "  \"releaseId\": \"123\",\n" +
                                                    "  \"name\": \"releaseName\",\n" +
                                                    "  \"projectOrigin\": \"projectOrigin\",\n" +
                                                    "  \"svmTrackingStatus\": \"svmComponentId\",\n" +
                                                    "  \"shortStatus\": \"svmShortStatus\",\n" +
                                                    "  \"type\": \"OSS\"\n" +
                                                    "}\n" +
                                                    "]"
                                    ))
                    )
            }
    )
    @GetMapping(value = VULNERABILITIES_URL + "/trackingStatus" + "/{projectId}")
    public ResponseEntity<Map<String, Object>> getVulnerabilitiesTrackingStatus(
            @Parameter(description = "The ID of the project to be retrieved.")
            @PathVariable("projectId") String projectId,
            @Parameter(description = "Based on sort param data will get sorted.")
            @RequestParam(value = "sortBy", required = false, defaultValue = "name") String sortBy,
            @Parameter(description = "Based on sortorder param data will get sorted.")
            @RequestParam(value = "sortOrder", required = false, defaultValue = "asc") String sortOrder,
            @Parameter(description = "Pagination requests", schema = @Schema(implementation = OpenAPIPaginationHelper.class))
            Pageable pageable
    ) throws TException {
        List<Map<String, String>> vulTrackingStatusList = new ArrayList<>();
        try {
            User user = restControllerHelper.getSw360UserFromAuthentication();
            List<ReleaseClearingStatusData> releaseClearingStatusList = vulnerabilityService
                    .getReleasesClearingStatusWithAccessibility(user, projectId);
            releaseClearingStatusList.forEach(rel -> {
                if (rel.getRelease() != null) {
                    Map<String, String> vulnerabilityTrackingStatus = new TreeMap<>();
                    vulnerabilityTrackingStatus.put("releaseId", rel.getRelease().getId());
                    vulnerabilityTrackingStatus.put("name", rel.getRelease().getName());
                    vulnerabilityTrackingStatus.put("projectOrigin", rel.getProjectNames());
                    vulnerabilityTrackingStatus.put("svmTrackingStatus",
                            (rel.getRelease().getExternalIds() != null && rel.getRelease().getExternalIds().containsKey(SW360Constants.SVM_COMPONENT_ID))
                                    ? "tracked"
                                    : "not tracked");
                    vulnerabilityTrackingStatus.put("shortStatus",
                            (rel.getRelease().getAdditionalData() != null && rel.getRelease().getAdditionalData().containsKey(SW360Constants.SVM_SHORT_STATUS))
                                    ? rel.getRelease().getAdditionalData().get(SW360Constants.SVM_SHORT_STATUS)
                                    : "");
                    vulnerabilityTrackingStatus.put("type", rel.getComponentType().toString());
                    vulTrackingStatusList.add(vulnerabilityTrackingStatus);
                }
            });
            if (sortBy.isEmpty() || sortBy.isBlank()) {
                sortBy = "name";
            }
            getSortedList(sortBy, sortOrder, vulTrackingStatusList);
            Map<String, Object> createPagination = createPaginationMetadata(pageable, vulTrackingStatusList);
            return ResponseEntity.ok(createPagination);
        } catch (SW360Exception e) {
            throw new TException(e.why);
        } catch (Exception ex) {
            throw new TException(ex.getMessage());
        }
    }

    public Map<String, Object> createPaginationMetadata(Pageable pageable, List<Map<String, String>> listOfItems) {
        int pageSize = pageable.getPageSize();
        int pageNumber = pageable.getPageNumber();
        int start = pageNumber * pageSize;
        int end = Math.min(start + pageSize, listOfItems.size());
        List<Map<String, String>> paginatedList = listOfItems.subList(start, end);
        int totalPages = (int) Math.ceil((double) listOfItems.size() / pageSize);
        Map<String, Integer> pagination =  Map.of(
            "size", pageSize,
            "totalElements", listOfItems.size(),
            "totalPages", totalPages,
            "number", pageNumber
        );
        Map<String, Object> responseBody = new HashMap<>();
        responseBody.put("page", pagination);
        responseBody.put("vulnerabilityTrackingStatus", paginatedList);
        return responseBody;
    }

    private void getSortedList(String sortBy, String sortOrder, List<Map<String, String>> vulTrackingStatusList) {
        Collections.sort(vulTrackingStatusList, new Comparator<Map<String, String>>() {
            public int compare(Map<String, String> m1, Map<String, String> m2) {
                if ("asc".equalsIgnoreCase(sortOrder)) {
                    return (m1.get(sortBy)).compareTo(m2.get(sortBy));
                } else {
                    return (m2.get(sortBy)).compareTo(m1.get(sortBy));
                }
            }
        });
    }
}
