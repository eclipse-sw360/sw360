/*
 * Copyright Siemens AG, 2021. Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.clients.adapter;

import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.sw360.clients.rest.SW360VulnerabilityClient;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360ReleaseVulnerabilityRelation;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360Vulnerability;
import org.eclipse.sw360.clients.utils.FutureUtils;

/**
 * Adapter implementation for the SW360 Vulnerabilities endpoint.
 */
class SW360VulnerabilityClientAdapterAsyncImpl implements SW360VulnerabilityClientAdapterAsync {
	private final SW360VulnerabilityClient vulnerabilityClient;

	public SW360VulnerabilityClientAdapterAsyncImpl(SW360VulnerabilityClient client) {
		vulnerabilityClient = client;
	}

	@Override
	public SW360VulnerabilityClient getVulnerabilityClient() {
		return vulnerabilityClient;
	}

	@Override
	public CompletableFuture<Optional<SW360Vulnerability>> getVulnerabilityByExternalId(String externalId) {
		return FutureUtils.optionalFuture(getVulnerabilityClient().getVulnerabilityByExternalId(externalId));
	}

	@Override
	public CompletableFuture<List<SW360Vulnerability>> getVulnerabilities() {
		return getVulnerabilityClient().getVulnerabilities();
	}

	@Override
	public CompletableFuture<SW360Vulnerability> createVulnerability(SW360Vulnerability vulnerability) {
		return FutureUtils.wrapInFuture(() -> {
			if (vulnerability.getId() != null) {
				throw new IllegalArgumentException("Vulnerability already has the id " + vulnerability.getId());
			}
			return SW360VulnerabilityAdapterUtils.validateVulnerability(vulnerability);
		}, "Cannot create vulnerability with external Id - " + vulnerability.getExternalId())
				.thenCompose(getVulnerabilityClient()::createVulnerability);
	}

	@Override
	public CompletableFuture<SW360Vulnerability> updateVulnerability(SW360Vulnerability vulnerability,
			String externalId) {
		return FutureUtils.wrapInFuture(() -> {
			if (StringUtils.isBlank(vulnerability.getExternalId())) {
				throw new IllegalArgumentException("Cannot update vulnerability without external ID");
			}
			return SW360VulnerabilityAdapterUtils.validateVulnerability(vulnerability);
		}, "Cannot update release for " + vulnerability.getExternalId())
				.thenCompose(vulnerabilityVerified -> getVulnerabilityClient().patchVulnerability(vulnerabilityVerified,
						externalId));
	}

	@Override
	public CompletableFuture<Integer> deleteVulnerability(String externalId) {
		return getVulnerabilityClient().deleteVulnerability(externalId);
	}

	@Override
	public CompletableFuture<SW360ReleaseVulnerabilityRelation> createVulnerabilityReleaseRelation(String externalId,
			SW360ReleaseVulnerabilityRelation releaseVulnerabilityRelation) {
		return FutureUtils.wrapInFuture(() -> {
			if (StringUtils.isBlank(externalId)) {
				throw new IllegalArgumentException("Cannot create vulnerability release relation without external ID");
			}
			return SW360VulnerabilityAdapterUtils.validateReleaseVulnerabilityRelation(releaseVulnerabilityRelation);
		}, "Cannot create vulnerability release relation with external Id - " + externalId)
				.thenCompose(vulnerablitiValidated -> getVulnerabilityClient()
						.createVulnerabilityReleaseRelation(externalId, vulnerablitiValidated));
	}

	@Override
	public CompletableFuture<Integer> deleteVulnerabilityReleaseRelation(String externalId, String releaseId) {
		return getVulnerabilityClient().deleteVulnerabilityReleaseRelation(externalId, releaseId);
	}
}
